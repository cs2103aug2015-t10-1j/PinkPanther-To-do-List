# A0126473E
###### src\common\Auxiliary.java
``` java
package common;

public class Auxiliary {
	
	public static String getFirstWord(String userInput) {
		String commandTypeString = userInput.trim().split("\\s+")[0];
		return commandTypeString;
	}
	
	public static String removeFirstWord(String userInput) {
		String commandContent = userInput.replaceFirst(getFirstWord(userInput), "").trim();
		return commandContent;
	}
	
	public static String[] trimStringArray(String[] arr) {
		for (int i = 0; i < arr.length; i++) {
			arr[i] = arr[i].trim();
		}
		return arr;
	}
	
	public static boolean isEmptyArray(String[] arr) {
		for (int i = 0; i < arr.length; i++) {
			if (!(arr[i].trim().isEmpty())){
				return false;
			}
		}
		return true;
	}
	
	public static boolean isNumber(String possiblyNumber) {
		return !possiblyNumber.isEmpty() && possiblyNumber.replaceAll("[0-9]","").isEmpty();
	}
	
	public static String concatArray(String[] arr) {
		String arrContents = "";
		if (arr != null) {
			arrContents += arr[0];
			for (int i = 1; i < arr.length; i++) {
				arrContents += ", ";
				arrContents += arr[i];
			}
		}
		return arrContents;
	}
	
	public static void displayErrorMessage(String errorMessage) {
		System.out.println(errorMessage);
	}
}
```
###### src\parser\AddStringParser.java
``` java
package parser;

import common.Task;
import common.TaskType;
import common.Auxiliary;
import common.Display;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.logging.Level;
import java.util.logging.Logger;

public class AddStringParser implements Parser {
	
	// attributes
	private String taskNameStore;
	private LocalDate startDateStore;
	private LocalDate endDateStore;
	private LocalTime startTimeStore;
	private LocalTime endTimeStore;
	private TaskType taskTypeStore;
	private SingleDateParser sdp;
	private SingleTimeParser stp;
	
	// indices and indicators
	private static final int INDEX_TASK_NAME = 0;
	private static final int INDEX_TASK_DETAIL = 1;
	private static final int INDEX_DATE = 0;
	private static final int INDEX_TIME = 1;
	
	// word list
	private static final String[] LIST_TWO_DATE_MARKERS = {" to ", "-"};
	private static final String[] LIST_DEADLINE_MARKERS = {"by", "due", "before"}; 
	private static final String[] LIST_START_MARKERS = {"at", "after"};
	
	// mythical stuff
	private static final LocalDate THE_MYTH_DAY = LocalDate.of(1979, 7, 11);
	
	// limits/min/max
	private static final int MAX_ALLOWED_DATES_TIMES = 2;
	private static final int NO_VALID_DATES_TIMES_FOUND = 0;
	private static final int SINGLE_DATE_TIME_FOUND = 1;
	private static final int DATE_TIME_RANGE_FOUND = 2;
	
	// messages
	private static final String MESSAGE_EMPTY_TASK = 
			"You have not entered any task details.";
	private static final String MESSAGE_PARSER_ERROR = 
				"You have entered invalid input that broke the program.";
	private static final String MESSAGE_EASTER_EGG = 
			"This day is too mythical for you to perform any tasks!";
	private static final String MESSAGE_ASSERTION_NULL = 
			 "Logic error. Null input is passed in as parameter!";
	private static final String MESSAGE_ASSERTION_EMPTY_USER_INPUT = 
			"Empty user input not fully accounted for!";
	private static final String MESSAGE_ASSERTION_INVALID_INDEX =
			"Invalid index entered! Pls refer to limits/max/min list of valid indices.";
	private static final String MESSAGE_ASSERTION_NOT_CHRONOLOGICAL =
			"Date or time range not fixed properly to ensure chronology.";
	private static final String MESSAGE_LOG_NO_DETAILS = 
			"Detected no task details. Returning null to Logic.";
	private static final String MESSAGE_LOG_PARSER_ERROR = 
			"Parser logic is broken.";
	private static final String MESSAGE_LOG_START_DATE_CHANGE = 
			"Start date detected and updated to %s.";
	private static final String MESSAGE_LOG_END_DATE_CHANGE = 
			"End date detected and updated to %s.";
	private static final String MESSAGE_LOG_START_TIME_CHANGE = 
			"Start time detected and updated to %s.";
	private static final String MESSAGE_LOG_END_TIME_CHANGE = 
			"End time detected and updated to %s.";
	private static final String MESSAGE_LOG_EASTER_EGG = 
			"Task falls on restricted date. Returning null to logic.";
	private static final String MESSAGE_LOG_FLOATING = 
			"Returning floating Task %s to logic.";
	private static final String MESSAGE_LOG_DEADLINE = 
			"Returning deadline Task %s to logic.";
	private static final String MESSAGE_LOG_TODO = 
			"Returning to-do Task %s to logic.";
	private static final String MESSAGE_LOG_EVENT = 
			"Returning event Task %s to logic.";
	private static final String MESSAGE_LOG_RESET = 
			"All stores in parser cleared.";
	
	// other constants
	private static final Logger log = Logger.getLogger("AddStringParser");
	
	/**
	 * Constructor
	 */
	public AddStringParser() {
		sdp = new SingleDateParser();
		stp = new SingleTimeParser();
	}
	
	/**
	 * Return a Task based on commandContent.
	 * null is returned when commandContent is empty.
	 * 
	 * @param commandContent	What the user enters.
	 * @return	Task containing info from commandContent.
	 */
	public Task parse(String commandContent){
		clearStores();
		assert commandContent != null : MESSAGE_ASSERTION_NULL;
		
		String[] userInfo = commandContent.split(",");
		userInfo = Auxiliary.trimStringArray(userInfo);
		
		if (Auxiliary.isEmptyArray(userInfo)) {
			log.log(Level.INFO, MESSAGE_LOG_NO_DETAILS);
			Display.setFeedBack(MESSAGE_EMPTY_TASK);
			return null;
		}

		assert !Auxiliary.isEmptyArray(userInfo) : MESSAGE_ASSERTION_EMPTY_USER_INPUT ;
		
		setTaskName(userInfo[INDEX_TASK_NAME]);
		int validDateTimes = findValidDateTime(userInfo);
		
		if (userInfo.length == 1 || validDateTimes == NO_VALID_DATES_TIMES_FOUND) {
			return addFloating(commandContent);
		} else if (validDateTimes == DATE_TIME_RANGE_FOUND)  {
			return addEvent(userInfo);
		} else if (validDateTimes == SINGLE_DATE_TIME_FOUND)  {
			return addSingleDated();
		} else {
			log.log(Level.WARNING, MESSAGE_LOG_PARSER_ERROR);
			Display.setFeedBack(MESSAGE_PARSER_ERROR);
			return null;
		}
	}
	
	private int findValidDateTime(String [] possiblyDateTime) {
		assert possiblyDateTime != null : MESSAGE_ASSERTION_NULL; 
		
		int dateCounter = 0;
		int timeCounter = 0;
		for (int i = INDEX_TASK_DETAIL; i < possiblyDateTime.length; i++) {
			int dateCount = countValidDates(possiblyDateTime[i]);
			int timeCount = countValidTimes(possiblyDateTime[i]);
			dateCounter += dateCount;
			timeCounter += timeCount;
			
			if (dateCount == NO_VALID_DATES_TIMES_FOUND 
					&& timeCount == NO_VALID_DATES_TIMES_FOUND) {
				if (dateCounter == NO_VALID_DATES_TIMES_FOUND 
						&& timeCounter == NO_VALID_DATES_TIMES_FOUND) {
					appendTaskName(possiblyDateTime[i]);
				} else {
					return NO_VALID_DATES_TIMES_FOUND;
				}
			}
			
		}
		if (Math.max(dateCounter, timeCounter) > MAX_ALLOWED_DATES_TIMES) {
			return NO_VALID_DATES_TIMES_FOUND;
		}
		return Math.max(dateCounter, timeCounter);
	}
	
	/**
	 * Return the number of valid dates found in a string.
	 * If valid dates are found, date and time stores are updated.
	 * 
	 * @param dateTimeInfo	An input token from the user.
	 * @return	The number of valid dates found in input token.
	 */
	public int countValidDates(String dateTimeInfo) {
		assert dateTimeInfo != null : MESSAGE_ASSERTION_NULL;
		
		// case: itself is a date
		if (isSingleDateTime(dateTimeInfo, sdp)) {
			if (startDateStore == null) {
				setStartDate(sdp.parse(dateTimeInfo));
				log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
						getStartDate()));
			} else {
				setEndDate(sdp.parse(dateTimeInfo));
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
						getEndDate()));
			}
			return SINGLE_DATE_TIME_FOUND;
		}
		
		// case: starts with a date indicator and is a date
		if (isSingleDateTime(Auxiliary.removeFirstWord(dateTimeInfo), sdp)) {
			String dateIndicator = Auxiliary.getFirstWord(dateTimeInfo);
			
			for (int i = 0; i < LIST_DEADLINE_MARKERS.length; i++) {
				if (dateIndicator.equalsIgnoreCase(LIST_DEADLINE_MARKERS[i])) {
					setEndDate(sdp.parse(Auxiliary.removeFirstWord(dateTimeInfo)));
					setTaskType(TaskType.DEADLINE);
					log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
							getEndDate()));
					return SINGLE_DATE_TIME_FOUND;
				}
			}
			for (int i = 0; i < LIST_START_MARKERS.length; i++) {
				if (dateIndicator.equalsIgnoreCase(LIST_START_MARKERS[i])) {
					if (taskTypeStore != TaskType.DEADLINE) {
						setTaskType(TaskType.TODO);
					}
					setStartDate(sdp.parse(Auxiliary.removeFirstWord(dateTimeInfo)));
					log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
							getStartDate()));
					return SINGLE_DATE_TIME_FOUND;
				}
			}
			return NO_VALID_DATES_TIMES_FOUND;
		}
		
		// case: is a range of dates
		for (int i= 0; i < LIST_TWO_DATE_MARKERS.length; i++) {
			if (dateTimeInfo.contains(LIST_TWO_DATE_MARKERS[i])) {
				return findDuration(LIST_TWO_DATE_MARKERS[i], 
						dateTimeInfo, INDEX_DATE);
			}
		}
		// case: neither of the above
		return NO_VALID_DATES_TIMES_FOUND;
	}
	
	private int countValidTimes (String dateTimeInfo) {
		assert dateTimeInfo != null : MESSAGE_ASSERTION_NULL;

		// case: itself is a time
		if (isSingleDateTime(dateTimeInfo, stp)) {
			if (startTimeStore == null) {
				setStartTime(stp.parse(dateTimeInfo));
				log.log(Level.FINE, String.format(MESSAGE_LOG_START_TIME_CHANGE, 
						getStartTime()));
			} else {
				setEndTime (stp.parse(dateTimeInfo));
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_TIME_CHANGE, 
						getEndTime()));
			}
			return SINGLE_DATE_TIME_FOUND;
		}
		
		// case: starts with a time indicator and is a time
		if (isSingleDateTime(Auxiliary.removeFirstWord(dateTimeInfo), stp)) {
			String timeIndicator = Auxiliary.getFirstWord(dateTimeInfo);
			
			for (int i = 0; i < LIST_DEADLINE_MARKERS.length; i++) {
				if (timeIndicator.equalsIgnoreCase(LIST_DEADLINE_MARKERS[i])) {
					setEndTime(stp.parse(Auxiliary.removeFirstWord(dateTimeInfo)));
					setTaskType(TaskType.DEADLINE);
					log.log(Level.FINE, String.format(MESSAGE_LOG_END_TIME_CHANGE, 
							getEndTime()));
					return SINGLE_DATE_TIME_FOUND;
				}
			}
			for (int i = 0; i < LIST_START_MARKERS.length; i++) {
				if (timeIndicator.equalsIgnoreCase(LIST_START_MARKERS[i])) {
					if (taskTypeStore != TaskType.DEADLINE) {
						setTaskType(TaskType.TODO);
					}
					setStartTime(stp.parse(Auxiliary.removeFirstWord(dateTimeInfo)));
					log.log(Level.FINE, String.format(MESSAGE_LOG_START_TIME_CHANGE, 
							getStartTime()));
					return SINGLE_DATE_TIME_FOUND;
				}
			}
			return NO_VALID_DATES_TIMES_FOUND;
		}
		
		// case: is a range of times
		for (int i= 0; i < LIST_TWO_DATE_MARKERS.length; i++) {
			if (dateTimeInfo.contains(LIST_TWO_DATE_MARKERS[i])) {
				return findDuration(LIST_TWO_DATE_MARKERS[i], dateTimeInfo, INDEX_TIME);
			}
		}
		// case: neither of the above
		return NO_VALID_DATES_TIMES_FOUND;
	}
	
	private int findDuration(String delimiter, String dateTimes, int dateTimeIndicatorIndex) {
		assert (dateTimeIndicatorIndex == 0 || dateTimeIndicatorIndex == 1) 
			: MESSAGE_ASSERTION_INVALID_INDEX ;
		
		int delimOccurrence = dateTimes.length() - dateTimes.replaceAll(delimiter, "").length();
		if (delimOccurrence == delimiter.length()) {
			String[] dateTimeTokens = dateTimes.split(delimiter);
			dateTimeTokens = Auxiliary.trimStringArray(dateTimeTokens);
			
			if (dateTimeTokens.length > 1) {
				if (dateTimeIndicatorIndex == INDEX_TIME 
						&& isValidTimeRange(dateTimeTokens[0], dateTimeTokens[1])) {
					return DATE_TIME_RANGE_FOUND;
				} else if (dateTimeIndicatorIndex == INDEX_DATE
						&& isValidDateRange(dateTimeTokens[0], dateTimeTokens[1])) {
					return DATE_TIME_RANGE_FOUND;
				}
			}
		}
		return NO_VALID_DATES_TIMES_FOUND;
	}
	
	private boolean isValidDateRange(String firstDate, String secondDate) {
		LocalDate earlierDate = sdp.parse(firstDate);
		LocalDate laterDate = sdp.parse(secondDate);
		
		// case: need to convert first date to a valid date
		if (laterDate != null) {
			if (Auxiliary.isNumber(firstDate)) {
				int dayOfFirstDate = Integer.parseInt(firstDate);
				if (dayOfFirstDate <= laterDate.getDayOfMonth()) {
					earlierDate = laterDate.withDayOfMonth(dayOfFirstDate);
					assert !earlierDate.isAfter(laterDate) 
						: MESSAGE_ASSERTION_NOT_CHRONOLOGICAL;
				}
			}
		}
		
		// case: both dates are valid dates
		if (earlierDate != null && laterDate != null) {
			Boolean firstDateHasAppendedYear = sdp.fixDate(firstDate).getSecond();
			Boolean secondDateHasAppendedYear = sdp.fixDate(secondDate).getSecond();
			
			// if earlier date's year was appended
			if (firstDateHasAppendedYear && !secondDateHasAppendedYear) {
				earlierDate = earlierDate.withYear(laterDate.getYear());
				if (earlierDate.isAfter(laterDate)) {
					earlierDate = earlierDate.minusYears(1);
					assert !earlierDate.isAfter(laterDate) 
						: MESSAGE_ASSERTION_NOT_CHRONOLOGICAL;
				}
				
			// if later date's year or both dates' years were appended
			} else if (secondDateHasAppendedYear) {
				if (!firstDateHasAppendedYear)
					laterDate = laterDate.withYear(earlierDate.getYear());
				if (laterDate.isBefore(earlierDate)) {
					laterDate = laterDate.plusYears(1);
					assert !earlierDate.isAfter(laterDate) 
						: MESSAGE_ASSERTION_NOT_CHRONOLOGICAL;
				}
			}
			
			// check if chronological
			// date can still be non chronological parser did not append 
			// and check the years of the input
			if (!earlierDate.isAfter(laterDate)) {
				setStartDate(earlierDate);
				log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
						getStartDate()));
				setEndDate(laterDate);
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
						getEndDate()));
				return true;
			}
		}
		return false;
	}
	
	private boolean isValidTimeRange(String firstTime, String secondTime) {
		LocalTime earlierTime = stp.parse(firstTime);
		LocalTime laterTime = stp.parse(secondTime);
		
		// case: need to append "am/pm" to first time
		if (laterTime != null) {
			if (secondTime.contains("pm") && !firstTime.contains("pm")) {
				firstTime += "pm";
				if (stp.parse(firstTime) != null) {
					earlierTime = stp.parse(firstTime);
				}
			} else if (secondTime.contains("am") && !firstTime.contains("am")) {
				firstTime += "am";
				if (stp.parse(firstTime) != null) {
					earlierTime = stp.parse(firstTime);
				}
			}
		}
		
		// case: both times are valid times
		if (earlierTime != null && laterTime != null) {
			
			// check if chronological
			if (!earlierTime.isAfter(laterTime)) {
				setStartTime(earlierTime);
				log.log(Level.FINE, String.format(MESSAGE_LOG_START_TIME_CHANGE, 
						getStartTime()));
				setEndTime(laterTime);
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_TIME_CHANGE, 
						getEndTime()));
				return true;
			}
		}
		return false;
	}
	
	private Task addFloating(String details) {
		Task floating = new Task(details);
		log.log(Level.INFO, String.format(MESSAGE_LOG_FLOATING, details));
		return floating;
	}
	
	private Task addEvent(String[] details)  {		
		String taskFullDetails = Auxiliary.concatArray(details);
		
		// case: 0-1 T 0-1 D (2 deadlines/todo indicators entered)
		// case: 1 T 2 D (drop time and add untimed dated event)
		// case: 0 T 2 D (add dated event)
		if (startTimeStore == null || endTimeStore == null) {
			if (startDateStore == null || endDateStore == null) {
				return addFloating(taskFullDetails);
			}
			
			assert startDateStore != null : MESSAGE_ASSERTION_NULL;
			assert endDateStore != null : MESSAGE_ASSERTION_NULL;
			
			if (startDateStore.equals(endDateStore)) {
				return addSingleDated();
			}
			setStartTime(null);
			log.log(Level.FINE, String.format(MESSAGE_LOG_START_TIME_CHANGE, 
					getStartTime()));
			setEndTime(null);
			log.log(Level.FINE, String.format(MESSAGE_LOG_END_TIME_CHANGE, 
					getEndTime()));
			
			if (!endDateStore.isAfter(startDateStore)) {
				return addFloating(taskFullDetails);
			}
		} else {
			
			// case: 2 T 0 D (from time T1-T2 today)
			if (startDateStore == null && endDateStore == null) {
				setStartDate(LocalDate.now());
				log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
						getStartDate()));
				setEndDate(LocalDate.now());
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
						getEndDate()));
			}
			
			// case: 2 T 1 D (from time T1-T2 on 1D)
			if (startDateStore == null || endDateStore == null) {
				if (startDateStore != null) {
					setEndDate(startDateStore);
					log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
							getEndDate()));
				} else {
					setStartDate(endDateStore);
					log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
							getStartDate()));
				}
			}
			
			// case: 2 T 2 D
			if (endTimeStore.isBefore(startTimeStore)) {
				// not allowing for tasks that has a start date-time and an end date-time
				return addFloating(taskFullDetails);
			}
			if (endDateStore.isEqual(startDateStore)) {
				if  (!endTimeStore.isAfter(startTimeStore)){
					return addSingleDated();
				}
			} else if (endDateStore.isBefore(startDateStore)) {
				return addFloating(taskFullDetails);
			}
		}
		
		Task event = new Task(taskNameStore, startDateStore, 
				 startTimeStore, endDateStore, endTimeStore);			
		
		if (isDuringRestrictedDate(event)) {
			Display.setFeedBack(MESSAGE_EASTER_EGG);
			log.log(Level.INFO, MESSAGE_LOG_EASTER_EGG);
			return null;
		}	
		log.log(Level.INFO, String.format(MESSAGE_LOG_EVENT, 
				event.toString()));
		return event;
	}
	
	private Task addSingleDated() {
		
		// case: 1 T 0 D (add todo/deadline today)
		if (startDateStore == null && endDateStore == null) {
			setStartDate(LocalDate.now());
			log.log(Level.FINE, String.format(MESSAGE_LOG_START_DATE_CHANGE, 
					getStartDate()));
			setEndDate(LocalDate.now());
			log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
					getEndDate()));
		}
		
		// case: 1 T 1 D (add todo or deadline on 1D)
		// case: 0 T 1 D (add dated event on 1D)
		if (taskTypeStore == TaskType.DEADLINE) {
			if (endDateStore == null && startDateStore != null) {
				setEndDate(startDateStore);
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_DATE_CHANGE, 
						getEndDate()));
			}
			if (endTimeStore == null && startTimeStore != null) {
				setEndTime(startTimeStore);
				log.log(Level.FINE, String.format(MESSAGE_LOG_END_TIME_CHANGE, 
						getEndTime()));
			}
			Task deadline = new Task(taskNameStore, endDateStore, endTimeStore,
					TaskType.DEADLINE);
			
			if (deadline.getDate().isEqual(THE_MYTH_DAY)) {
				Display.setFeedBack(MESSAGE_EASTER_EGG);
				log.log(Level.INFO, MESSAGE_LOG_EASTER_EGG);
				return null;
			}
			log.log(Level.INFO, String.format(MESSAGE_LOG_DEADLINE, 
					deadline.toString()));
			return deadline;

		} else if (taskTypeStore == TaskType.TODO 
				|| (startDateStore != null)) {
			Task toDoAt = new Task(taskNameStore, startDateStore, startTimeStore,
					TaskType.TODO);
			if (toDoAt.getDate().isEqual(THE_MYTH_DAY)) {
				Display.setFeedBack(MESSAGE_EASTER_EGG);
				log.log(Level.INFO, MESSAGE_LOG_EASTER_EGG);
				return null;
			}			
			log.log(Level.INFO, String.format(MESSAGE_LOG_TODO, 
					toDoAt.toString()));
			return toDoAt;
			
		} else {
			log.log(Level.WARNING, MESSAGE_LOG_PARSER_ERROR);
			return null;
		}
	}
	
	private boolean isDuringRestrictedDate(Task task) {
		return !(task.getStartDate().isAfter(THE_MYTH_DAY) 
				|| task.getEndDate().isBefore(THE_MYTH_DAY)); 
	}
	
	/**
	 * Resets all attributes of parser to null
	 */
	protected void clearStores() {
		setTaskName(null);
		setStartDate(null);
		setEndDate(null);
		setStartTime(null);
		setEndTime(null);
		setTaskType(null);
		log.log(Level.FINE, MESSAGE_LOG_RESET);
	}
	
	public boolean isSingleDateTime (String dateTime, Parser parser) {
		assert dateTime != null : MESSAGE_ASSERTION_NULL;
		assert parser != null : MESSAGE_ASSERTION_NULL;
		
		if (parser.parse(dateTime) != null) {
			return true;
		}
		return false;
	}
	
	// accessors for testing
	public String getTaskName() {
		return taskNameStore;
	}
	
	public LocalDate getStartDate() {
		return startDateStore;
	}
	
	public LocalDate getEndDate() {
		return endDateStore;
	}
	
	public LocalTime getStartTime() {
		return startTimeStore;
	}
	
	public LocalTime getEndTime() {
		return endTimeStore;
	}
	
	public TaskType getTaskType() {
		return taskTypeStore;
	}
	
	// mutators
	public void setTaskName(String newName) {
		taskNameStore = newName;
	}
	
	public void appendTaskName(String additionalDetails) {
		taskNameStore = taskNameStore + ", " + additionalDetails;
	}
	
	public void setStartDate(LocalDate date) {
		startDateStore = date;
	}
	
	public void setEndDate(LocalDate date) {
		endDateStore = date;
	}
	
	public void setStartTime(LocalTime time) {
		startTimeStore = time;
	}
	
	public void setEndTime(LocalTime time) {
		endTimeStore = time;
	}
	
	public void setTaskType(TaskType type) {
		taskTypeStore = type;
	}
}
```
###### src\parser\CommandParser.java
``` java
package parser;

import common.Task;
import common.Pair;

import java.time.LocalDate;
import java.util.ArrayList;

/** 
 * Facade class for Logic*/
public class CommandParser {
	
	// attributes
	private AddStringParser asp;
	private QueryParser qp;
	private DateRangeParser drp;
	
	/**
	 * Constructor
	 */
	public CommandParser() {
		asp = new AddStringParser();
		qp = new QueryParser();
		drp = new DateRangeParser(asp);
	}
	
	public Task createTask(String userInput){
		Task task = asp.parse(userInput);
		return task;
	}
	
	public Pair<LocalDate,ArrayList<Integer>> query(String userInput){
		return qp.parse(userInput);
	}
	
	public Pair<LocalDate,LocalDate> queryDateRange(String userInput){
		return drp.parse(userInput);
	}

}
```
###### src\parser\DateRangeParser.java
``` java
package parser;

import common.Pair;
import java.time.LocalDate;
import java.util.logging.Logger;
import java.util.logging.Level;

public class DateRangeParser implements Parser {
	
	// attributes
	private AddStringParser asp;
	
	// indices and indicators
	private static final int SINGLE_DATE_TIME_FOUND = 1;
	private static final int DATE_TIME_RANGE_FOUND = 2;
	
	// messages
	private static final String MESSAGE_ASSERTION_NULL = 
			 "Logic error. Null input is passed in as parameter!";
	private static final String MESSAGE_LOG_LEGIT_DATE = 
			"A single date detected. Returning Pair of range %1$s to %1$s to logic.";
	private static final String MESSAGE_LOG_DATE = 
			"A deadline detected. Returning Pair of range %1$s to %1$s to logic anyways.";
	private static final String MESSAGE_LOG_DATE_RANGE = 
			"Range of dates detected. Returning Pair of range %1$s to %2$s to logic.";
	private static final String MESSAGE_LOG_PARSE_FAIL = 
			"No dates detected. Returning null to logic.";
	
	// other constants
	private static final Logger log = Logger.getLogger("DateRangeParser");
	
	/**
	 * Constructor
	 */
	public DateRangeParser(AddStringParser asp) {
		this.asp = asp;
	}
	
	/**
	 * Return a Pair of a dates that specify a range.
	 * null is returned when no valid date is found.
	 * 
	 * @param commandContent	What the user enters.
	 * @return	A range of dates.
	 */
	public Pair<LocalDate, LocalDate> parse(String commandContent) {
		asp.clearStores();
		assert commandContent != null : MESSAGE_ASSERTION_NULL;
		
		int validDates = asp.countValidDates(commandContent);
		if (validDates == SINGLE_DATE_TIME_FOUND) {
			if (asp.getStartDate() != null) {
				log.log(Level.INFO, String.format(MESSAGE_LOG_LEGIT_DATE,
						asp.getStartDate()));
				return new Pair<LocalDate, LocalDate>(asp.getStartDate(), asp.getStartDate());
			}
			log.log(Level.INFO, String.format(MESSAGE_LOG_DATE, asp.getEndDate()));
			return new Pair<LocalDate, LocalDate>(asp.getEndDate(), asp.getEndDate()); 
		} else if (validDates == DATE_TIME_RANGE_FOUND) {
			log.log(Level.INFO, String.format(MESSAGE_LOG_DATE_RANGE, asp.getStartDate(),
					asp.getEndDate()));
			return new Pair<LocalDate, LocalDate>(asp.getStartDate(), asp.getEndDate());
		}
		log.log(Level.INFO, MESSAGE_LOG_PARSE_FAIL);
		return null;
	}
}
```
###### src\parser\Parser.java
``` java
package parser;

public interface Parser {
	public Object parse(String input);
}
```
###### src\parser\QueryParser.java
``` java
package parser;

import common.Pair;
import common.Auxiliary;
import common.Display;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

public class QueryParser implements Parser {
	
	// attributes
	private SingleDateParser sdp;
	
	// indices and indicators
	private static final int INDEX_KEYWORD = 0;
	private static final int INDEX_INDEX = 1;
	
	// messages
	private static final String MESSAGE_ASSERTION_NULL = 
			"Logic error. Null input is passed in as parameter!";
	private static final String MESSAGE_INVALID_COMMA= 
			"Invalid input format.";
	private static final String MESSAGE_INVALID_KEYWORD = 
			"Invalid keyword or date entered.";
	private static final String MESSAGE_INVALID_INDEX =
			"Invalid index entered.";
	private static final String MESSAGE_ASSERTION_COMMA = 
			"Unaccounted case where #commas detected is not 1.";
	private static final String MESSAGE_LOG_INVALID_FORMAT = 
			"Invalid input format. Returning null to logic.";
	private static final String MESSAGE_LOG_INVALID_KEYWORD = 
			"No valid keyword detected. Returning null to logic.";
	private static final String MESSAGE_LOG_INVALID_INDEX = 
			"Invalid index detected. Returning null to logic.";
	private static final String MESSAGE_LOG_PARSE_SUCCESS = 
			"Returning Task indices of %1$s on %2$s to logic.";
	private static final String MESSAGE_LOG_NON_NUMERICAL_INDEX = 
			"Non numerical index detected in list of indices.";

	// other constants
	private static final Logger log = Logger.getLogger("QueryParser");
	
	/**
	 * Constructor
	 */
	public QueryParser() {
		sdp = new SingleDateParser();
	}
	
	/**
	 * Return a Pair of a date and an ArrayList of indices.
	 * null is returned when no valid date or index is found.
	 * 
	 * @param commandContent	What the user enters.
	 * @return	A certain date and the list of indices for that date.
	 */
	public Pair<LocalDate,ArrayList<Integer>> parse(String commandContent) {
		assert commandContent != null : MESSAGE_ASSERTION_NULL;
		String[] userInfo = commandContent.split(",");
		userInfo = Auxiliary.trimStringArray(userInfo);
		
		// there should only be 1 comma
		if (userInfo.length != 2) {
			Display.setFeedBack(MESSAGE_INVALID_COMMA);
			log.log(Level.INFO, MESSAGE_LOG_INVALID_FORMAT);
			return null;
		}
		assert userInfo.length == 2 : MESSAGE_ASSERTION_COMMA;
		
		LocalDate keyword = generateKeyword(userInfo[INDEX_KEYWORD]);
		ArrayList<Integer> indexList = generateIndexList(userInfo[INDEX_INDEX]);
		
		if (isValidKeyword(userInfo[INDEX_KEYWORD]) 
				&& isValidIndex(userInfo[INDEX_INDEX], indexList)) {
			log.log(Level.INFO, String.format(MESSAGE_LOG_PARSE_SUCCESS, 
					indexList, keyword));
			return new Pair<LocalDate, ArrayList<Integer>>(keyword, indexList);
		} else if (!isValidKeyword(userInfo[INDEX_KEYWORD])) {
			Display.setFeedBack(MESSAGE_INVALID_KEYWORD);
			log.log(Level.INFO, MESSAGE_LOG_INVALID_KEYWORD);
			return null;
		} else if (!isValidIndex(userInfo[INDEX_INDEX], indexList)) {
			Display.setFeedBack(MESSAGE_INVALID_INDEX);
			log.log(Level.INFO, MESSAGE_LOG_INVALID_INDEX);
			return null;
		}
		return null;
	}
	
	private LocalDate generateKeyword (String keyword) {
		return sdp.parse(keyword);
	}
	
	private ArrayList<Integer> generateIndexList(String userInfo) {
		assert userInfo != null : MESSAGE_ASSERTION_NULL;
		String[] listOfIndices = userInfo.split(" ");
		ArrayList<Integer> list = new ArrayList<Integer>();
		for (int i = INDEX_KEYWORD; i < listOfIndices.length; i++) {
			try {
				list.add(Integer.valueOf(listOfIndices[i]));
			} catch (NumberFormatException e) {
				log.log(Level.FINE, MESSAGE_LOG_NON_NUMERICAL_INDEX);
				return null;
			}
		}	
		return list;
	}
	
	private boolean isValidKeyword (String keyword) {
		return keyword.equalsIgnoreCase("undated") || sdp.parse(keyword) != null;
	}
	
	private boolean isValidIndex (String indices, ArrayList<Integer> indexList) {
		return indices.equalsIgnoreCase("all") || indexList != null;
	}
}

```
###### src\parser\SingleDateParser.java
``` java
package parser;

import common.Pair;
import common.Auxiliary;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.DateTimeException;
import java.util.List;
import java.util.Collections;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SingleDateParser implements Parser {
	
	// Class attributes
	private static ArrayList<String> validDateFormats;
	private static ArrayList<String> validDayFormats;
	
	// indices and indicators
	private static final int INDEX_DAY = 0;
	private static final int INDEX_MONTH = 1;
	
	// messages
	private static final String MESSAGE_ASSERTION_NULL = 
			 "Logic error. Null input is passed in as parameter!";
	private static final String MESSAGE_LOG_PARSE_SUCCESS = 
			"Successful parsing. Returning a LocalDate.";
	private static final String MESSAGE_LOG_PARSE_FAIL = 
			"Not a date. Returning null.";
	private static final String MESSAGE_LOG_INVALID_FORMAT = 
			"Not an accepted format of date. Returning null.";
	private static final String MESSAGE_LOG_YEAR_APPENDED =
			"Year of the date is appended.";
	private static final String MESSAGE_LOG_DATE_FIXED =
			"Date has been fixed.";
	private static final String MESSAGE_LOG_DATE_NOT_FIXED =
			"Date has not been fixed.";
	
	// word/format lists
	private static final String[] DATE_DELIMITERS = {"/", "-", " "};
	private static final List<String> DATE_FORMAT_SLASH = 
			Collections.unmodifiableList(Arrays.asList("d/M/yy", "dd/M/yy",
		    		"d/MM/yy", "dd/MM/yy", "d/MMM/yy", "dd/MMM/yy",  "d/MMMM/yy",
		    		"dd/MMMM/yy", "d/M/yyyy", "dd/M/yyyy", "d/MM/yyyy", "dd/MM/yyyy",
		    		"d/MMM/yyyy", "dd/MMM/yyyy", "d/MMMM/yyyy", "dd/MMMM/yyyy"));
	private static final List<String> DATE_FORMAT_DASH = 
			Collections.unmodifiableList(Arrays.asList("d-M-yy", "dd-M-yy",
		    		"d-MM-yy", "dd-MM-yy", "d-MMM-yy", "dd-MMM-yy", "d-MMMM-yy",
		    		"dd-MMMM-yy", "d-M-yyyy", "dd-M-yyyy", "d-MM-yyyy", "dd-MM-yyyy",
		    		"d-MMM-yyyy", "dd-MMM-yyyy", "d-MMMM-yyyy", "dd-MMMM-yyyy"));
	private static final List<String> DATE_FORMAT_SPACE = 
			Collections.unmodifiableList(Arrays.asList("d M yy", "dd M yy",
		    		"d MM yy", "dd MM yy", "d MMM yy", "dd MMM yy", "d MMMM yy", 
		    		"dd MMMM yy", "d M yyyy", "d MM yyyy", "d MM yyyy", "dd MM yyyy", 
		    		"d MMM yyyy", "dd MMM yyyy", "d MMMM yyyy", "dd MMMM yyyy"));
	private static final List<String> DAY_FORMAT = 
			Collections.unmodifiableList(Arrays.asList("EEE", "EEEE"));
	private static final String[] DATE_INDICATORS_ONE = {"TONIGHT", "NOW", "TODAY",
			"TOMORROW",};
	
	// other constants
	private static final Logger log = Logger.getLogger("SingleDateParser");
	
	public SingleDateParser() {
		validDateFormats = new ArrayList<String>();
		validDayFormats = new ArrayList<String>();
		validDateFormats.addAll(DATE_FORMAT_SLASH);
		validDateFormats.addAll(DATE_FORMAT_DASH);
		validDateFormats.addAll(DATE_FORMAT_SPACE);
		validDayFormats.addAll(DAY_FORMAT);
	}
	
	/**
	 * Return a date based on user input.
	 * null is returned when user input is not a date.
	 * 
	 * @param date	What the user enters.
	 * @return	LocalDate object of the date that was entered.
	 */
	public LocalDate parse(String date) {
		assert date != null : MESSAGE_ASSERTION_NULL;
		
		// case: dates that contain a certain keyword
		if (isDateIndicator(date)) {
			log.log(Level.FINE, MESSAGE_LOG_PARSE_SUCCESS);
			return oneWordIndicatorParser(date);
		}

		if (hasDateIndicator(date)) {
			log.log(Level.FINE, MESSAGE_LOG_PARSE_SUCCESS);
			return twoWordIndicatorParser(date);
		}
		
		// case: dates without keywords
		Pair<String, Boolean>fixDateDetails = fixDate(date);
		String fixedDate = fixDateDetails.getFirst();
		for (String dateFormat : validDateFormats) {
			LocalDate parsedDate = compareDateFormat(fixedDate, dateFormat);
			if (parsedDate != null) {
				log.log(Level.FINE, MESSAGE_LOG_PARSE_SUCCESS);
				return parsedDate;
			}
		}
		
		// case: not a date
		log.log(Level.FINE, MESSAGE_LOG_PARSE_FAIL);
		return null;
	}
	
	private LocalDate compareDateFormat(String dateString, String pattern) {
		assert pattern != null : MESSAGE_ASSERTION_NULL;
		
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			LocalDate date = LocalDate.parse(dateString, formatter);
			return date;
		} catch (DateTimeException e) {
			log.log(Level.FINER, MESSAGE_LOG_INVALID_FORMAT);
			return null;
		}
	}
	
	/**
	 * Return a Pair of a date ready for parsing and
	 * a boolean value of whether its year was appended.
	 * 
	 * @param date	A date String that the user enters.
	 * @return	A Pair with the first object as a fixed date String formatted
	 * 			in a way that the DateTimeFormatter accepts, and a boolean
	 * 			reflecting whether the year was appended.
	 */
	public Pair<String, Boolean> fixDate(String date) {
		assert date != null : MESSAGE_ASSERTION_NULL;
		
		String fixedDate;
		boolean hasAppendedYear = false;
		
		for (int i = 0; i < DATE_DELIMITERS.length; i++){	
			String[] dateDetails = date.split(DATE_DELIMITERS[i]);
			if (dateDetails.length > 1) {
				dateDetails = Auxiliary.trimStringArray(dateDetails);
				fixedDate = dateDetails[INDEX_DAY];
				
				// fix month
				dateDetails[INDEX_MONTH] = 
						dateDetails[INDEX_MONTH].substring(0,1).toUpperCase() 
							+ dateDetails[INDEX_MONTH].substring(1).toLowerCase();
				
				// fix year
				for (int j = 1; j < dateDetails.length; j++) {
					String appendedContent = DATE_DELIMITERS[i] + dateDetails[j];
					fixedDate += appendedContent;
				}
				
				if (dateDetails.length < 3 ) {
					String appendedYear = DATE_DELIMITERS[i] 
							+ String.valueOf(LocalDate.now().getYear());
					fixedDate += appendedYear;
					hasAppendedYear = true;
					log.log(Level.FINEST, MESSAGE_LOG_YEAR_APPENDED);
				}
				log.log(Level.FINER, MESSAGE_LOG_DATE_FIXED);
				return new Pair<String, Boolean>(fixedDate, hasAppendedYear);
			}
		}
		log.log(Level.FINER, MESSAGE_LOG_DATE_NOT_FIXED);
		return new Pair<String, Boolean>(date, hasAppendedYear);
	}
	
	private boolean isDateIndicator(String date) {
		for (int i = 0; i < DATE_INDICATORS_ONE.length; i++) {
			if (date.equalsIgnoreCase(DATE_INDICATORS_ONE[i])) {
				return true;
			}
		}
		
		return false;
	}
	
	private LocalDate oneWordIndicatorParser(String date) {
		date = date.toUpperCase();
		switch (date) {
			case "TODAY":
			case "TONIGHT":
			case "NOW":
				return LocalDate.now();
			case "TOMORROW":
				return LocalDate.now().plusDays(1);
			default:
		}
		return null;
	}
	
	private boolean hasDateIndicator(String date) {
		return date.toUpperCase().contains("THIS") || date.toUpperCase().contains("NEXT");
	}

	private LocalDate twoWordIndicatorParser (String date) {
		String precursor = Auxiliary.getFirstWord(date).toUpperCase();
		String content = Auxiliary.removeFirstWord(date).toUpperCase().trim();
		assert content != null : MESSAGE_ASSERTION_NULL;
		
		if (content.length() > 1) {
			content = content.substring(0,1) + content.substring(1).toLowerCase();
		}	
		LocalDate parsedDay = parseDayOfWeek(content);
		if (precursor.equals("THIS")) {
			if (parsedDay != null && parsedDay.isBefore(LocalDate.now())) {
				return parsedDay.plusWeeks(1);
			}
			return parseDayOfWeek(content);
		} else if (precursor.equals("NEXT")) {
			if (content.equals("Week")) {	
				return LocalDate.now().plusWeeks(1);
			} else if (content.equals("Month")) {
				return LocalDate.now().plusMonths(1);
			} else if (content.equals("Year")) {
				return LocalDate.now().plusYears(1);
			} else if (parsedDay != null) {
				return parsedDay.plusWeeks(1);
			}
		}
		return null;
	}
	
	private LocalDate parseDayOfWeek(String dayOfWeek) {
		DayOfWeek day = null;
		int dayIndicator = 0;
		for (String dayFormat : DAY_FORMAT) {
			day = compareDayFormat(dayOfWeek, dayFormat);
			if (day != null) {
				dayIndicator = day.getValue();
			}
		}
		if (dayIndicator == 0) {
			return null;
		}
		
		int dayToday = LocalDate.now().getDayOfWeek().getValue();
		int differenceInDays = dayIndicator - dayToday;
		if (differenceInDays >= 0) {
			return LocalDate.now().plusDays(differenceInDays);
		} else if (differenceInDays < 0) {
			return LocalDate.now().minusDays(Math.abs(differenceInDays));
		}
		return null;
	}
	
	private DayOfWeek compareDayFormat(String dateString, String pattern) {
		assert pattern != null : MESSAGE_ASSERTION_NULL;
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			DayOfWeek day = DayOfWeek.from(formatter.parse(dateString));
			return day;
		} catch (DateTimeException e) {
			log.log(Level.FINER, MESSAGE_LOG_INVALID_FORMAT);
			return null;
		}
	}
}
```
###### src\parser\SingleTimeParser.java
``` java
package parser;

import java.time.DateTimeException;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SingleTimeParser implements Parser{
	
	// Class attributes
	private static ArrayList<String> validTimeFormats;
	
	// messages
	private static final String MESSAGE_ASSERTION_NULL = 
			 "Logic error. Null input is passed in as parameter!";
	private static final String MESSAGE_LOG_PARSE_SUCCESS = 
			"Successful parsing. Returning a LocalTime.";
	private static final String MESSAGE_LOG_PARSE_FAIL = 
			"Not a time. Returning null.";
	private static final String MESSAGE_LOG_INVALID_FORMAT = 
			"Not an accepted format of time. Returning null.";
	
	// word/format lists
	private static final List<String> TIME_FORMATS= 
			Collections.unmodifiableList(Arrays.asList("h:mma", "hh:mma", 
					"h.mma", "hh.mma", "hmma", "hhmma", "H:mm", "HH:mm", 
					"H.mm", "HH.mm", "Hmm", "HHmm", "ha", "hha"));
	private static final String[] TIME_INDICATORS = {"TONIGHT", "NOW", "MORNING",
			"AFTERNOON", "NIGHT"};
	
	// other constants
	private static final Logger log = Logger.getLogger("SingleTimeParser");
	
	public SingleTimeParser() {
		validTimeFormats = new ArrayList<String>();
		validTimeFormats.addAll(TIME_FORMATS);
	}

	/**
	 * Return a time based on user input.
	 * null is returned when user input is not a time.
	 * 
	 * @param time	What the user enters.
	 * @return	LocalTime object of the time that was entered.
	 */
	public LocalTime parse(String time) {
		assert time != null : MESSAGE_ASSERTION_NULL;
		time = time.toUpperCase();
		
		// case: times that contain a certain keyword
		for (int i = 0; i < TIME_INDICATORS.length; i++) {
			if (time.equals(TIME_INDICATORS[i])) {
				log.log(Level.FINE, MESSAGE_LOG_PARSE_SUCCESS);
				return parseTimeWord(time);
			}
		}
		
		// case: times without keywords
		for (String timeFormat : validTimeFormats) {
			LocalTime parsedTime = compareTimeFormat(time, timeFormat);
			if (parsedTime != null) {
				log.log(Level.FINE, MESSAGE_LOG_PARSE_SUCCESS);
				return parsedTime;
			}
		}
		
		// case: not a time
		log.log(Level.FINE, MESSAGE_LOG_PARSE_FAIL);
		return null;
	}
	
	private LocalTime compareTimeFormat(String timeString, String pattern) {
		assert pattern != null : MESSAGE_ASSERTION_NULL;
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			LocalTime time = LocalTime.parse(timeString, formatter);
			return time;
		} catch (DateTimeException e) {
			log.log(Level.FINER, MESSAGE_LOG_INVALID_FORMAT);
			return null;
		}

	}
	
	private LocalTime parseTimeWord (String time) {
		switch (time) {
			case "NOW":
				return LocalTime.now().truncatedTo(ChronoUnit.MINUTES);
			case "TONIGHT":
			case "NIGHT":
				return LocalTime.of(19,0);
			case "MORNING":
				return LocalTime.of(9,0);
			case "AFTERNOON":
				return LocalTime.of(12,0);
			default:
		}
		return null;
	}
}
```
###### src\tests\AddStringParserTest.java
``` java
package tests;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import org.junit.Test;

import parser.AddStringParser;
import parser.SingleDateParser;
import common.Task;

public class AddStringParserTest {

	DateTimeFormatter dtf = DateTimeFormatter.ofPattern("d/M/YYYY");
	String dateToday = LocalDate.now().format(dtf);
	String dateNextWeek = LocalDate.now().plusWeeks(1).format(dtf);
	
	AddStringParser asp = new AddStringParser();
	SingleDateParser sdp = new SingleDateParser();
	
	@Test
	public void testAddFloating() {
		String[] taskContents = {"something, yes", "cats are cool",
				"eat string beans, 24 feg, 5p.m.", 
				"dinner, candies, 24/7, no, next friday",
				"24/7/2015", "do laundry, 11-7pm",
				"watch the football games, 10pm, 2/7, 5am, 3/7",
				"HOLIDAYS!, 9-1 august"};
		String[] expectedDetails = {"something, yes", "cats are cool",
				"eat string beans, 24 feg, 5p.m.", 
				"dinner, candies, 24/7, no, next friday",
				"24/7/2015", "do laundry, 11-7pm",
				"watch the football games, 10pm, 2/7, 5am, 3/7",
				"HOLIDAYS!, 9-1 august"};
		for (int i = 0; i < taskContents.length; i++) {
			Task actualTask = asp.parse(taskContents[i]);
			Task expectedTask = new Task(expectedDetails[i]);
			assertEquals(expectedTask.toString(), actualTask.toString());
		}
	}
	
	@Test
	public void testAddTodoPositive() {
		String[] taskContents = {"something, 4/9", "whatever, today",
				"water the plants, afternoon", 
				"dine with cats, dogs and rabbits, at 2pm",
				"explore Narnia, after 7pm, 15/6", ",5/8/1989"};
		String[] expectedDetails = {"something, at 4/9/2015", 
				"whatever, at " + dateToday,
				"water the plants, at 12.00PM, " + dateToday, 
				"dine with cats, dogs and rabbits, at 2.00PM, " +dateToday,
				"explore Narnia, at 7.00PM, 15/6/2015", ", at 5/8/1989"};
		for (int i = 0; i < taskContents.length; i++) {
			Task actualTask = asp.parse(taskContents[i]);
			Task expectedTask = new Task(expectedDetails[i]);
			assertEquals(expectedTask.toString(), actualTask.toString());
		}
	}
	
	@Test
	public void testAddDeadlinePositive() {
		String[] taskContents = {"something, by 4/9", "whatever, due 5pm",
				"water the plants, before 23/4, at 2pm", 
				"dine with cats, dogs and rabbits, by 17 jun, by 9.28pm"};
		String[] expectedDetails = {"something, by 4/9/2015", 
				"whatever, by 5.00PM, " + dateToday,
				"water the plants, by 2.00PM, 23/4/2015", 
				"dine with cats, dogs and rabbits, by 9.28PM, 17/6/2015"};
		for (int i = 0; i < taskContents.length; i++) {
			Task actualTask = asp.parse(taskContents[i]);
			Task expectedTask = new Task(expectedDetails[i]);
			assertEquals(expectedTask.toString(), actualTask.toString());
		}
	}
	
	@Test
	public void testAddEventsPositive() {
		String[] taskContents = {"something, 2-3pm",
				"whatever, 4 to 5 jan 2016, 2-4am",
				"feed cats, today, next week, 10am, 1733"};
		String[] expectedDetails = {"something, 2.00PM to 3.00PM, " + dateToday, 
				"whatever, 2.00AM to 4.00AM, 4/1/2016 to 5/1/2016",
				"feed cats, 10.00AM to 5.33PM, " + dateToday + " to " + dateNextWeek};
		for (int i = 0; i < taskContents.length; i++) {
			Task actualTask = asp.parse(taskContents[i]);
			Task expectedTask = new Task(expectedDetails[i]);
			assertEquals(expectedTask.toString(), actualTask.toString());
		}
	}
	
	@Test
	public void testAddEmpty() {
		String[] taskContents = {"", ",", ",,,,,,"};
		for (int i = 0; i < taskContents.length; i++) {
			Task actualTask = asp.parse(taskContents[i]);
			assertEquals(null, actualTask);
		}
	}
}
```
###### src\tests\DateRangeParserTest.java
``` java
package tests;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.AddStringParser;
import parser.DateRangeParser;
import common.Pair;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

@SuppressWarnings("unchecked")
public class DateRangeParserTest {

	AddStringParser asp = new AddStringParser();
	DateRangeParser drp = new DateRangeParser(asp);
	
	DateTimeFormatter dtf = DateTimeFormatter.ofPattern("EEE");
	String dayTodayFull = LocalDate.now().getDayOfWeek().toString();
	String dayToday = LocalDate.now().format(dtf);
	
	@Test
	public void testDateRangeParsingPositive() {
		String[] testInput = {"2-4/8/2017", "7-12 may 2005", "11 to 13-2-2016", 
				"11/jun/2015 - 12/Jul/2015", "2 to 5-2", " 7 - 21 Jun 2015",
				"20 nov to 2 dec 2017", " 4 Apr 2013-6 May", " 30 nov - 16 Jan",
				"17 october - 8 May 2018", "6/3/2012-22/2"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2017, 8, 2), 
				LocalDate.of(2005, 5, 7), LocalDate.of(2016, 2, 11), 
				LocalDate.of(2015, 6, 11), LocalDate.of(2015, 2, 2),
				LocalDate.of(2015, 6, 7), LocalDate.of(2017, 11, 20),
				LocalDate.of(2013, 4, 4), LocalDate.of(2015, 11, 30),
				LocalDate.of(2017, 10, 17), LocalDate.of(2012, 3, 6)};
		LocalDate[] expectedOutputSecond = {LocalDate.of(2017, 8, 4), 
				LocalDate.of(2005, 5, 12), LocalDate.of(2016, 2, 13), 
				LocalDate.of(2015, 7, 12), LocalDate.of(2015, 2, 5),
				LocalDate.of(2015, 6, 21), LocalDate.of(2017, 12, 2),
				LocalDate.of(2013, 5, 6), LocalDate.of(2016, 1, 16),
				LocalDate.of(2018, 5, 8), LocalDate.of(2013, 2, 22)};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(expectedOutputSecond[i], testOutput[i].getSecond());
		}
	}
	
	@Test
	public void testDateRangeParsingBoundaryPositive() {
		String[] testInput = {"7-31/9", "1/1/00-2/2/00", "2/2-7 nov 2015", "4-6"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2015, 9, 7), 
				LocalDate.of(2000, 1, 1), LocalDate.of(2015, 2, 2),
				LocalDate.of(2015, 6, 4)};
		LocalDate[] expectedOutputSecond = {LocalDate.of(2015, 9, 30), 
				LocalDate.of(2000, 2, 2), LocalDate.of(2015, 11, 7),
				LocalDate.of(2015, 6, 4)};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(expectedOutputSecond[i], testOutput[i].getSecond());
		}
	}
	
	@Test
	public void testDateRangeParsingBoundaryNegative() {
		String[] testInput = {"31-30/9", "1/1/1-2/2/1", "5-5-2015-6-6-2016"};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}
	}
	
	@Test
	// done on a Sunday
	// please change the sundays in this test to your current day
	public void testDateRangeSingleDateParsingPositive() {
		String[] testInput = {"toDAy", "nOw", "Tonight", "tomorrOW",
				"next week", "next month", "next year",
				"this " + dayTodayFull, "next " + dayToday, "28 Feb 2016", 
				"4 March", "3 07 2015", "01 01", "14/Jul/2016", "5/September", 
				"15/02/2015", "09/04", "20-May-14", "19-November", 
				"13-08-2018", "9-3" };
		LocalDate[] expectedOutputFirst = {LocalDate.now(), LocalDate.now(),
				LocalDate.now(), LocalDate.now().plusDays(1),
				LocalDate.now().plusWeeks(1), LocalDate.now().plusMonths(1), 
				LocalDate.now().plusYears(1), LocalDate.now(), 
				LocalDate.now().plusWeeks(1), LocalDate.of(2016, 2, 28), 
				LocalDate.of(2015, 3, 4), LocalDate.of(2015, 7, 3), 
				LocalDate.of(2015, 1, 1), LocalDate.of(2016, 7, 14), 
				LocalDate.of(2015, 9, 5), LocalDate.of(2015, 2, 15), 
				LocalDate.of(2015, 4, 9), LocalDate.of(2014, 5, 20), 
				LocalDate.of(2015, 11, 19), LocalDate.of(2018, 8, 13), 
				LocalDate.of(2015, 3, 9)};
		LocalDate[] expectedOutputSecond = {LocalDate.now(), LocalDate.now(),
				LocalDate.now(), LocalDate.now().plusDays(1),
				LocalDate.now().plusWeeks(1), LocalDate.now().plusMonths(1), 
				LocalDate.now().plusYears(1), LocalDate.now(), 
				LocalDate.now().plusWeeks(1), LocalDate.of(2016,2,28), 
				LocalDate.of(2015, 3, 4), LocalDate.of(2015, 7, 3), 
				LocalDate.of(2015, 1, 1), LocalDate.of(2016, 7, 14), 
				LocalDate.of(2015, 9, 5), LocalDate.of(2015, 2, 15), 
				LocalDate.of(2015, 4, 9), LocalDate.of(2014, 5, 20), 
				LocalDate.of(2015, 11, 19), LocalDate.of(2018, 8, 13), 
				LocalDate.of(2015, 3, 9)};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(expectedOutputSecond[i], testOutput[i].getSecond());
		}
	}
	
	@Test
	// leap years and range correction
	public void testDateRangeSingleDateParsingBoundaryPositive() {
		String[] testInput = {"31 Feb 2016", "31 April", 
				"31/June/2016", "31/09/2015", "31-noV-14", 
				"29/2/2015", "29/2/2016", "29/2/2017", "29/2/2018",
				"20/7/3999", "20/7/00"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2016, 2, 29), 
				LocalDate.of(2015, 4, 30), LocalDate.of(2016, 6, 30), 
				LocalDate.of(2015, 9, 30), LocalDate.of(2014, 11, 30), 
				LocalDate.of(2015, 2, 28), LocalDate.of(2016, 2, 29), 
				LocalDate.of(2017, 2, 28), LocalDate.of(2018, 2, 28), 
				LocalDate.of(3999, 7, 20), LocalDate.of(2000, 7, 20)};
		LocalDate[] expectedOutputSecond = {LocalDate.of(2016, 2, 29), 
				LocalDate.of(2015, 4, 30), LocalDate.of(2016, 6, 30), 
				LocalDate.of(2015, 9, 30), LocalDate.of(2014, 11, 30), 
				LocalDate.of(2015, 2, 28), LocalDate.of(2016, 2, 29), 
				LocalDate.of(2017, 2, 28), LocalDate.of(2018, 2, 28), 
				LocalDate.of(3999, 7, 20), LocalDate.of(2000, 7, 20)};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(expectedOutputSecond[i], testOutput[i].getSecond());
		}
	}
	
	@Test
	public void testDateRangeSingleDateParsingBoundaryNegative() {
		String[] testInput = {"32 07 2015", "00 01", "32/jun", 
				"34/09", "32-November", "32-08-2018",
				"29/13/2015", "1/0/1997", "20/7/0"};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}
	}
	
	@Test
	public void testDateRangeSingleDateParsingNegative() {
		String[] testInput = {"Wednesday", "goodnight", "30July", "-", "",
				"this week", "this month", "this year",
				"never saturday", "cat sat", "hopping rabbits",
				"28.Feb.2016", "hello", "meow",
				"14/Jules/Verne", "5/Pikachu", "15/Febuary/2015"};
		Pair <LocalDate, LocalDate>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = drp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}
	}
}
```
###### src\tests\QueryParserTest.java
``` java
package tests;

import static org.junit.Assert.*;

import org.junit.Test;

import common.Display;
import common.Pair;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;

import parser.QueryParser;

@SuppressWarnings("unchecked")
public class QueryParserTest {
	
	QueryParser qp = new QueryParser();
	
	@Test
	public void testQueryParsingOneIndex() {
		String[] testInput = {"11 Jul 2017, 1", "4/1/1991, 0", "2-11, 12", 
				"tomorrow, 299", "undAted, 20"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2017, 7, 11), 
				LocalDate.of(1991, 1, 4), LocalDate.of(2015, 11, 2),
				LocalDate.now().plusDays(1), null};
		Integer[] expectedOutputSecond = {1, 0, 12, 299, 20};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(expectedOutputSecond[i], testOutput[i].getSecond().get(0));
		}
	}
	
	@Test
	public void testQueryParsingMultipleIndices() {
		String[] testInput = {"11 Jul 2017, 2 7 9 3", "undated, 12 45 10234"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2017, 7, 11), 
				 null};
		Integer[][] expectedOutputSecond = {{2, 7, 9, 3}, {12, 45, 10234}};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			ArrayList<Integer> arrayList = new ArrayList<Integer>(Arrays.asList(expectedOutputSecond[i]));
			assertEquals(arrayList, testOutput[i].getSecond());
		}
	}
	
	@Test
	public void testQueryParsingAllIndices() {
		String[] testInput = {"4/5, all", "undated, all"};
		LocalDate[] expectedOutputFirst = {LocalDate.of(2015, 5, 4), 
				 null};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(expectedOutputFirst[i], testOutput[i].getFirst());
			assertEquals(null, testOutput[i].getSecond());
		}
	}

	@Test
	public void testQueryParsingNegativeDueToCommas() {
		String[] testInput = {"4/5, 5/6, 9, 10", "17 nov 2015", ",,,,", ",", ""};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
			assertEquals("Invalid input format.",
					Display.showFeedBack());
		}
	}
	
	@Test
	public void testQueryParsingNegativeInvalidIndex() {
		String[] testInput = {"31 Mar 2015, 0 1 2 hello", "17 nov 2015, test",
				"20/9, "};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
			assertEquals("Invalid index entered.", Display.showFeedBack());
		}
	}
	
	@Test
	public void testQueryParsingNegativeInvalidDate() {
		String[] testInput = {"31Mar, 0", "21/20/1999, 17", "14, hello"};
		Pair <LocalDate, ArrayList<Integer>>[] testOutput = new Pair [testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = qp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
			assertEquals("Invalid keyword or date entered.",
					Display.showFeedBack());
		}
	}
}
```
###### src\tests\SingleDateParserTest.java
``` java
package tests;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.SingleDateParser;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class SingleDateParserTest {

	DateTimeFormatter dtf = DateTimeFormatter.ofPattern("EEE");
	String dayTodayFull = LocalDate.now().getDayOfWeek().toString();
	String dayToday = LocalDate.now().format(dtf);
	
	SingleDateParser sdp = new SingleDateParser();
	
	// Testing fixDate
	// Should work for both valid and invalid dates
	@Test
	public void testFixDatesWithoutYears() {
		String[] testInput = {"21 nov", "4/5", "39 sePTTmber ", 
				"7/fEB", "twenty two", "6-7", "dogs-cats"};
		String[] expectedOutput = {"21 Nov 2015", "4/5/2015",
				"39 Septtmber 2015", "7/Feb/2015", "twenty Two 2015",
				"6-7-2015", "dogs-Cats-2015"};
		String[] testOutput = new String[testInput.length];
		Boolean[] testOutputAppend = new Boolean[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.fixDate(testInput[i]).getFirst();
			testOutputAppend[i] = sdp.fixDate(testInput[i]).getSecond();
			assertEquals(expectedOutput[i], testOutput[i]);
			assertEquals(true, testOutputAppend[i]);
		}	
	}

	
	@Test
	public void testFixDatesWithYears() {
		String[] testInput = {"10 mAY 2015", "2/8/17", "39 cats 15",
				"7-fEB-1998", "I/like/cats"};
		String[] expectedOutput = {"10 May 2015", "2/8/17",
				"39 Cats 15", "7-Feb-1998", "I/Like/cats"};
		String[] testOutput = new String[testInput.length];
		Boolean[] testOutputAppend = new Boolean[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.fixDate(testInput[i]).getFirst();
			testOutputAppend[i] = sdp.fixDate(testInput[i]).getSecond();
			assertEquals(expectedOutput[i], testOutput[i]);
			assertEquals(false, testOutputAppend[i]);
		}	
	}
	
	@Test
	public void testFixGibberishFormats() {
		String[] testInput = {"twenty", "good.night", "30July", 
				"", "i love cats forever"};
		String[] expectedOutput = {"twenty", "good.night", "30July", 
				"", "i Love cats forever"};
		String[] testOutput = new String[testInput.length];
		Boolean[] testOutputAppend = new Boolean[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.fixDate(testInput[i]).getFirst();
			testOutputAppend[i] = sdp.fixDate(testInput[i]).getSecond();
			assertEquals(expectedOutput[i], testOutput[i]);
			assertEquals(false, testOutputAppend[i]);
		}	
	}
	
	// Testing parse
	@Test
	public void testParseOneWordNormal() {
		String[] testInput = {"toDAy", "nOw", "Tonight", "tomorrOW"};
		LocalDate[] expectedOutput = {LocalDate.now(), LocalDate.now(),
				LocalDate.now(), LocalDate.now().plusDays(1)};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseOneWordGibberish() {
		String[] testInput = {"Wednesday", "goodnight", "30July", ""};
		LocalDate[] expectedOutput = {null, null, null, null};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseTwoWordsNormal() {
		String[] testInput = {"next week", "next month", "next year",
				"this " + dayTodayFull, "next "+ dayToday};
		LocalDate[] expectedOutput = {LocalDate.now().plusWeeks(1), 
				LocalDate.now().plusMonths(1), LocalDate.now().plusYears(1), 
				LocalDate.now(), LocalDate.now().plusWeeks(1)};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseTwoWordsGibberish() {
		String[] testInput = {"this week", "this month", "this year",
				"never saturday", "cat sat", "hopping rabbits"};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}
	}
	
	@Test
	public void testParseDatesNormal() {
		String[] testInput = {"28 Feb 2016", "4 March", "3 07 2015",
				"01 01", "14/Jul/2016", "5/September", "15/02/2015",
				"09/04", "20-May-14", "19-November", "13-08-2018",
				"9-3"};
		LocalDate[] expectedOutput = {LocalDate.of(2016, 2, 28), 
				LocalDate.of(2015, 3, 4), LocalDate.of(2015, 7, 3), 
				LocalDate.of(2015, 1, 1), LocalDate.of(2016, 7, 14), 
				LocalDate.of(2015, 9, 5), LocalDate.of(2015, 2, 15), 
				LocalDate.of(2015, 4, 9), LocalDate.of(2014, 5, 20), 
				LocalDate.of(2015, 11, 19), LocalDate.of(2018, 8, 13), 
				LocalDate.of(2015, 3, 9)};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseDatesGibberish() {
		String[] testInput = {"28.Feb.2016", "hello", "meow",
				"14/Jules/Verne", "5/Pikachu", "15/Febuary/2015"};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}	
	}
	
	@Test
	// Leap years and date range correction
	public void testParseDatesBoundaryPositive() {
		String[] testInput = {"31 Feb 2016", "31 April", 
				"31/June/2016", "31/09/2015", "31-noV-14", 
				"29/2/2015", "29/2/2016", "29/2/2017", "29/2/2018",
				"20/7/3999", "20/7/00"};
		LocalDate[] expectedOutput = {LocalDate.of(2016, 2, 29), 
				LocalDate.of(2015, 4, 30), LocalDate.of(2016, 6, 30), 
				LocalDate.of(2015, 9, 30), LocalDate.of(2014, 11, 30), 
				LocalDate.of(2015, 2, 28), LocalDate.of(2016, 2, 29), 
				LocalDate.of(2017, 2, 28), LocalDate.of(2018, 2, 28), 
				LocalDate.of(3999, 7, 20), LocalDate.of(2000, 7, 20)};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}

	@Test
	// Dates that are really out of range
	public void testParseDatesBoundaryNegative() {
		String[] testInput = {"32 07 2015", "00 01", "32/jun", 
				"34/09", "32-November", "32-08-2018",
				"29/13/2015", "1/0/1997", "20/7/0"};
		LocalDate[] testOutput = new LocalDate[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = sdp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}	
	}
}
```
###### src\tests\SingleTimeParserTest.java
``` java
package tests;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.SingleTimeParser;

import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class SingleTimeParserTest {

	SingleTimeParser stp = new SingleTimeParser();
	
	@Test
	public void testParseOneWordTimes() {
		String[] testInput = {"tonight", "now", "morning",
				"afternoon", "night"};
		LocalTime[] expectedOutput = {LocalTime.of(19, 0), 
				LocalTime.now().truncatedTo(ChronoUnit.MINUTES),
				LocalTime.of(9, 0), LocalTime.of(12, 0), LocalTime.of(19, 0)};
		LocalTime[] testOutput = new LocalTime[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = stp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseOneWordGibberish() {
		String[] testInput = {"toonight", "never", "Wednesday",
				"99999", "meow"};
		LocalTime[] testOutput = new LocalTime[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = stp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}	
	}
	
	@Test
	public void testParseNormalTimes() {
		String[] testInput = {"12.20pm", "02.04Am", "7:19pm",
				"4:25PM", "3am", "1105pM", "105am", "2.45", "18.30",
				"23:11", "00:00", "2400", "0156"};
		LocalTime[] expectedOutput = {LocalTime.of(12, 20), 
				LocalTime.of(2, 4), LocalTime.of(19, 19), 
				LocalTime.of(16, 25), LocalTime.of(3, 0),
				LocalTime.of(23, 5), LocalTime.of(1, 5),
				LocalTime.of(2, 45), LocalTime.of(18, 30),
				LocalTime.of(23, 11), LocalTime.of(0, 0),
				LocalTime.of(0, 0), LocalTime.of(1, 56)};
		LocalTime[] testOutput = new LocalTime[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = stp.parse(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
	}
	
	@Test
	public void testParseTimesBoundaryNegative() {
		String[] testInput = {"12.2pm", "12.2", "2401", 
				"12318263", "-123", "-0000", "1 2", "a.p", "2p.m."};
		LocalTime[] testOutput = new LocalTime[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = stp.parse(testInput[i]);
			assertEquals(null, testOutput[i]);
		}	
	}
}
```

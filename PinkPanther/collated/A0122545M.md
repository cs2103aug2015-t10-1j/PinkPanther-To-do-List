# A0122545M
###### src\tests\ControllerTest.java
``` java
	@Test
	public void test_Controller_Return_To_Main_Calendar_Shortcut(){
		//This tests if Main Calendar can be displayed correctly by a call to controller
		state.setTitle("Viewing Helpscreen");
		controller.addCommand("view normal");
		assertEquals(state.getInputBoxText(),"");
		assertEquals(Display.showFeedBack(),"Input command into the field below.");
		assertEquals(state.getTitle(),"                         To-Do List");
		assertEquals((state.getOverdueList() != null), true);
	}
	
```
###### src\tests\ControllerTest.java
``` java
	@Test
	public void test_Controller_View_All_Calendar_Shortcut(){
		//This test checks if View All mode is implemented correctly, and overdue tasks should be displayed
		for (int i=0; i<10; i++){
			state.setTitle("Random scene name");
			controller.addCommand("add this is an overdue task" + i);
			controller.addCommand("view all");
			assertEquals(state.getInputBoxText(),"");
			assertEquals(Display.showFeedBack(),"Input 'view normal' to return to main calendar.");
			assertEquals(state.getTitle(),"              â—? Viewing: All Tasks â—?");
			assertEquals((state.getOverdueList() != null), true);
		}
	}
	
```
###### src\tests\ControllerTest.java
``` java
	@Test
	public void test_View_Overdue_Mode(){
		//This test is to check if program will change to Overdue mode correctly
		state.setTitle("Viewing Helpscreen");
		controller.addCommand("add this is a floating task");
		controller.addCommand("view overdue");
		assertEquals(state.getInputBoxText(),"");
		assertEquals(Display.showFeedBack(),"Input 'view normal' to return to main calendar.");
		assertEquals(state.getTitle(),"              â—? Viewing: Overdue Tasks â—?");
		//Floating list should be null as this screen does not show floating lists
		assertEquals(state.getFloatingList(),null);
	}

```
###### src\tests\ControllerTest.java
``` java
	@Test
	public void test_View_Normal_No_Overdue(){
		//This test is to check if overdue tasks erroneously appears in normal view
		Controller newController = new Controller();
		ProgramState newState = newController.getProgramState();
		state.setTitle("Random Title");
		newController.addCommand("add this is a floating task");
		newController.addCommand("add this is a dated task, tomorrow");
		newController.addCommand("view normal");
		assertEquals(newState.getInputBoxText(),"");
		assertEquals(Display.showFeedBack(),"Input command into the field below.");
		assertEquals(newState.getTitle(),"                         To-Do List");
		newController.addCommand("del 7 nov, all");
		assertEquals(newState.getOverdueList().isEmpty(), true);
	}

}
```
###### src\tests\SingleDateParserTest_NaturalLanguage.java
``` java
	public void test_Parser_PastDates() {
		//these test cases should 'gracefully fail' as parser does not
		//recognize natural language of past dates
		
		SingleDateParser dateParser = new SingleDateParser();

		assertEquals(dateParser.parse("yesterday"), null);	
		assertEquals(dateParser.parse("last month"), null);
		assertEquals(dateParser.parse("last year"), null);
	}
}
```
###### src\userinterface\ConsoleInputColorizer.java
``` java
package userinterface;

import java.util.ArrayList;

import common.Task;
import javafx.scene.layout.FlowPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import logic.Controller;
import parser.*;

public class ConsoleInputColorizer {
	private String DELIMITER_SPLIT_NAME = "[ ]+";
	
	//These strings are the feedbacks
	private String INDICATOR_ADDING = "Adding \u25b6  ";
	private String INDICATOR_DELETE = "Delete  \u25b6  ";
	private String INDICATOR_DONE = "  Done  \u25b6  ";
	private String INDICATOR_EDIT = "Editing \u25b6  ";
	private String INDICATOR_SEARCH = "Search \u25b6  ";
	private String INDICATOR_VIEW = "    View \u25b6  ";
	private String INDICATOR_DEFAULT = "             \u25b6  ";
	private String INDICATOR_EXIT = "Exit command detected: Program will close if you press ENTER.";
	private String INDICATOR_NOTFOUND = " [Valid task date and index not detected yet]";
	private String INDICATOR_TRUNCATED_DOTS = "...";
	
	private int INDEX_SECOND_WORD = 1;
	private int PARAMETER_STRING_SPLIT_TWO = 2;
	private String DELIMITER_STRING_SPLIT_SPACE = " ";
	private String FONT_TYPE_DEFAULT = "Tahoma";
	private int FONT_SIZE_DEFAULT = 17;
	private int TRIM_LENGTH_TASK_NAME = 20;
	private int TRIM_LENGTH_TASK_NAME_NON_BROKEN = 55;
	
	private String[] wordList = {};
	private String inputString;
	private Controller controller;
	
	/* 
	 * Gets string input and splits it into an array of strings, then calls colorize()
	 * @return FlowPane of colored texts
	 */
	public FlowPane parseInputToArray(String input) {
		if (input != null) {
			wordList = input.trim().split(DELIMITER_SPLIT_NAME);
			inputString = input;
		}
	    return colorize();
	}
	
	public void setController(Controller mainController) {
		controller = mainController;
	}

	/*Uses wordList and parses them through appropriate parsers.
	 *Searches for targeted tasks if they exist or breaks them down into representations of Tasks
	 *@return FlowPane of colored texts
	 */
	public FlowPane colorize() {
	    ArrayList<Text> textChunks = new ArrayList<>();
	    FlowPane bundle = new FlowPane();
	    
	    String offset = "";
	    textChunks.add(customize(offset, Color.TRANSPARENT));
    	bundle.getChildren().add(customize(offset, Color.TRANSPARENT));
	        switch (wordList[0].toLowerCase()) {
	        	
	        case "add":
	        	textChunks.add(customize(INDICATOR_ADDING, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];	
		        	if (taskInfo != null) {
		        		textChunks.addAll(breakTaskIntoFlowPane(controller.parseNewTask(taskInfo)));
		        	}
	        	}
	        	break;
	        	
	        case "del":
	        case "delete":
	        	textChunks.add(customize(INDICATOR_DELETE, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];	
		        	if (taskInfo != null) {
		        		Task task = controller.findTask(taskInfo);
		        		if (task != null) {
		        			textChunks.addAll(breakTaskIntoFlowPane(task));
		        		} else {
				        	textChunks.add(customize(INDICATOR_NOTFOUND, Color.RED));
			        	}
		        	}
	        	}
	        break;
	        
	        case "done":
	        	textChunks.add(customize(INDICATOR_DONE, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];	
		        	if (taskInfo != null) {
		        		Task task = controller.findTask(taskInfo);
		        		if (task != null) {
		        			textChunks.addAll(breakTaskIntoFlowPane(task));
		        		} else {
				        	textChunks.add(customize(INDICATOR_NOTFOUND, Color.RED));
			        	}
		        	}
	        	}
	        break;
	        
	        case "edit":
	        	textChunks.add(customize(INDICATOR_EDIT, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];	
		        	if (taskInfo != null) {
		        		try{
			        		Task task = controller.findTask(taskInfo);
			        		if (task != null) {
			        			textChunks.addAll(breakTaskIntoFlowPane(task));
			        		} else {
					        	textChunks.add(customize(" [Specify task date and index]", Color.RED));
				        	}
		        		} catch (NullPointerException e){
		        			
		        		}
		        		
		        	}
	        	}
	        break;
	        
	        case "exit":
	        	textChunks.add(customize(INDICATOR_EXIT, Color.RED));
	        break;
	        
	        case "search":
	        	textChunks.add(customize(INDICATOR_SEARCH, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];
		        	textChunks.add(customize(trimWord(taskInfo, TRIM_LENGTH_TASK_NAME_NON_BROKEN), Color.BLACK));
	        	}
	        break;
	        
	        case "view":
	        	textChunks.add(customize(INDICATOR_VIEW, Color.GREEN));
	        	if (wordList.length > 1) {
		        	String taskInfo = inputString.split(DELIMITER_STRING_SPLIT_SPACE, 
		        			PARAMETER_STRING_SPLIT_TWO)[INDEX_SECOND_WORD];
		        	textChunks.add(customize(trimWord(taskInfo, TRIM_LENGTH_TASK_NAME_NON_BROKEN), Color.BLACK));
	        	}
	        break;
	        
	        case "invalid":
	        case "unrecognized":
	        case "error":
	        	textChunks.add(customize(inputString, Color.RED));
	        break;
	        
	        default :
	        	textChunks.add(customize(INDICATOR_DEFAULT, Color.BROWN));
	        	textChunks.add(customize(trimWord(inputString, TRIM_LENGTH_TASK_NAME_NON_BROKEN), Color.BLACK));
	        break;
	        	
	        }

	    bundle.getChildren().addAll(textChunks);
	    return bundle;
	}
	
	//Ensures word is not too long and overflow window width by trimming it
	private String trimWord(String input, int maxLength) {
		if (input.length() >= maxLength) {
			return input.substring(0, maxLength) + INDICATOR_TRUNCATED_DOTS;
		}
		return input;
	}
	
	//Returns a colored Text representation of a string in specified color
	public Text customize(String word, Color color) {
		Text newText = new Text();
		newText.setText(word);
		newText.setFill(color);
		newText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_DEFAULT));
		return newText;
	}

	/* Gets a Task object and attempts to break it into text form.
	 * Will colorize each fragment accordingly, then return the ArrayList of these Texts.
	 * @return ArrayList<Text> of appropriately colored texts
	 */
	private ArrayList<Text> breakTaskIntoFlowPane(Task task) {
	    ArrayList<Text> textChunks = new ArrayList<>();
	    FlowPane bundle = new FlowPane();
	    
	    try {
		    if (task.getName() != null) {
		    	String taskName = task.getName();
		    	textChunks.add(customize("\"" + trimWord(taskName, TRIM_LENGTH_TASK_NAME) + "\"", Color.BLACK));
		    }
		    if(task.getStartTime()!=null) {
		    	textChunks.add(customize(" [â?°  " + task.getStartTime().toString(), Color.DARKCYAN));
		    	if(task.getEndTime()!=null) {
			    	textChunks.add(customize(" \u25b6 " + task.getEndTime().toString(), Color.DARKCYAN));
		    	}
		    	textChunks.add(customize("]", Color.DARKCYAN));
		    } else if(task.getEndTime()!=null) {
		    	textChunks.add(customize(" [by " + task.getEndTime().toString() + "]", Color.DARKCYAN));
		    }
		    if(task.getStartDate()!=null) {
		    	textChunks.add(customize(" [ðŸ“…  " + task.getStartDate().toString(), Color.TOMATO));
		    	if(task.getEndDate()!=null && !task.getEndDate().equals(task.getStartDate())) {
			    	textChunks.add(customize(" \u25b6 " + task.getEndDate().toString(), Color.TOMATO));
			    }
		    	textChunks.add(customize("]", Color.TOMATO));
		    }
		    else if(task.getEndDate()!=null) {
		    	textChunks.add(customize(" [" + task.getEndDate().toString() + "]", Color.TOMATO));
		    }
		    
	    } catch (NullPointerException e) {
	    	textChunks.add(customize(" [Please specify valid task name]", Color.RED));
	    }
	    
	    bundle.getChildren().addAll(textChunks);
	    return textChunks;
		
	}
}
```
###### src\userinterface\DayBox.java
``` java
package userinterface;

import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

public class DayBox extends StackPane{
	//These variables help to position objects in the StackPane
	private int Y_POS_DEFAULT = 1;
	private int X_POS_LEFT = 0;
	private int X_POS_CENTRE = 1;
	private int H_GAP_GRID = 5;

	//These variables help calibrate the entire DayBox's size
	private int WIDTH_ENTIRE_BOX = 230;
	private int HEIGHT_ENTIRE_BOX = 40;
	private int ARC_ENTIRE_BOX = 4;

	//These variables help calibrate and size the box that displays the number of date
	private int WIDTH_DAY_NUMBER_BOX = 35;
	private int HEIGHT_DAY_NUMBER_BOX = 35;
	private int ARC_DAY_NUMBER_BOX = 4;
	private Color COLOR_DAY_NUMBER_BOX = Color.DIMGRAY;
	private float STROKE_WIDTH_DAY_NUMBER_BOX = 2.0f;
	private Color FONT_COLOR_TEXT = Color.WHITE;
	private String FONT_TYPE_DEFAULT = "Tahoma";
	private int FONT_SIZE_DEFAULT = 20;

	//These strings denote what the box will display
	private String DISPLAY_STRING_UNDATED = "~";
	private String DISPLAY_STRING_OTHERS = "!";
	
	private String SPLIT_DATE_DELIMITER = " ";
	private String SPACE_OFFSET = " ";
	
	//These variables belong to the object
	String dayString, monthString;
	GridPane grid;
	
	//Constructor
	public DayBox(String date) {
		instantiateGrid();
		extractDayAndMonth (date);
		
		Rectangle box = createDayHolderBox(date);
		grid.add(box, X_POS_CENTRE, Y_POS_DEFAULT);	

		StackPane indexBox = createDayNumberBox(dayString);
		grid.add(indexBox, X_POS_LEFT, Y_POS_DEFAULT);
		
		Text text = instantiateText();
		grid.add(text, X_POS_CENTRE, Y_POS_DEFAULT);
		
		this.getChildren().addAll(grid);
	}
	
	//Forms a string representation of the date in appropriately sized Text
	private Text instantiateText() {
		Text text = new Text(SPACE_OFFSET + monthString);
		text.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, 25));
		text.setTextAlignment(TextAlignment.LEFT);
		text.setFill(Color.DIMGRAY);
		return text;
	}
	
	//Creates a grid to place items into
	private void instantiateGrid() {
		grid = new GridPane();
	    grid.setHgap(H_GAP_GRID);
	    grid.setVgap(H_GAP_GRID);
	}
	
	//Breaks date string into dayString and monthString
	private void extractDayAndMonth (String date) {
		if (date.equals("Undated Tasks")) {
	    	dayString = DISPLAY_STRING_UNDATED;
	    	monthString = date;
	    } 
	    else if (date.equals(DISPLAY_STRING_OTHERS)) {
	    	dayString = DISPLAY_STRING_OTHERS;
	    	monthString = "";
	    }
	    else {
	    	dayString = date.split(SPLIT_DATE_DELIMITER)[0];
	    	monthString = date.split(SPLIT_DATE_DELIMITER)[1] + SPACE_OFFSET + date.split(SPLIT_DATE_DELIMITER)[2];
	    }
	}
	
	//Returns a Rectangle that will serve as the background for whole date row
	private Rectangle createDayHolderBox(String day) {
		Rectangle box = new Rectangle();
		box.setWidth(WIDTH_ENTIRE_BOX);
		box.setHeight(HEIGHT_ENTIRE_BOX);
		box.setArcWidth(ARC_ENTIRE_BOX);
		box.setArcHeight(ARC_ENTIRE_BOX);
		box.setFill(Color.TRANSPARENT);
		return box;
	}
	
	//Returns a gray colored box that displays current day of month
	private StackPane createDayNumberBox(String num) {
		//Configure box dimensions and colors
		Rectangle box = new Rectangle();
		box.setWidth(WIDTH_DAY_NUMBER_BOX);
		box.setHeight(HEIGHT_DAY_NUMBER_BOX);
		box.setArcWidth(ARC_DAY_NUMBER_BOX);
		box.setArcHeight(ARC_DAY_NUMBER_BOX);                
		box.setFill(COLOR_DAY_NUMBER_BOX);
		box.setStroke(COLOR_DAY_NUMBER_BOX);
		box.setStrokeWidth(STROKE_WIDTH_DAY_NUMBER_BOX);
        
		//Configure Text in box
		Text text = new Text(num);
		text.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_DEFAULT));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(FONT_COLOR_TEXT);

		StackPane stackPane = new StackPane();
		stackPane.getChildren().addAll(box, text);
		return stackPane;
	}
}

```
###### src\userinterface\HelpScreen.java
``` java
package userinterface;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

public class HelpScreen extends ScrollPane{
	private static int FONT_SIZE_SCENE_TITLE = 32;
	private String FONT_TYPE_DEFAULT = "Tahoma";
	
	private static int FONT_SIZE_SCENE_BOX_CONTENTS = 20;
	private static int FONT_SIZE_COMMANDS_TEXTS = 25;
	private static int FONT_SIZE_SHORTCUTS = 13;

	//These coordinates help place objects correctly in the scene
	private static int X_POS_SCENE_TITLE = 2;
	private static int Y_POS_SCENE_TITLE = 1;
	private static int X_POS_TEXT_IN_GRID = 4;
	private static int Y_POS_TEXT_IN_GRID = 3;
	private static int X_POS_ICONBOX = 3;
	private static int Y_POS_ICONBOX = 3;
	private static int X_POS_NAMEBOX = 1;
	private static int Y_POS_NAMEBOX = 3;
	private static int X_POS_DESCRIPTION_BOX = 2;
	private static int Y_POS_DESCRIPTION_BOX = 3;
	private static int X_POS_STACKPANE = 2;
	private static int X_POS_LABEL_PANE = 1;
	private static int X_POS_DESCRIPTION_PANE = 2;
	private static int Y_POS_TEXTBOX_CHUNKS = 3;
	private static int X_POS_START_TEXTBOX_CHUNKS = 3;
	private static int Y_POS_SHORTCUTS_STARTING_POS = 15;
	
	private static float SIZE_STROKE_WIDTHS = 2.0f;
	private static int MULTIPLIER_BOX_TO_TEXT_SIZE = 10;
	
	//These dimensions size the individual rows of information
	private int HEIGHT_ENTIRE_BOX = 30;
	private int ARC_ENTIRE_BOX = 4;
	private static Color FONT_COLOR_DEFAULT = Color.DIMGRAY;

	//These coordinates help set window to be of correct size
	private int WIDTH_PREFERRED_WINDOW = 1080;
	private int HEIGHT_PREFERRED_WINDOW = 1060;
	private int H_PADDING_HELPSCREEN = 5;
	private int V_PADDING_HELPSCREEN = 7;
	private Insets INSET_GRID_DEFAULT = new Insets(10, 10, 10, 10);
	
	GridPane grid;
	int currentYPosition = 3;
	
	//Constructor
	public HelpScreen() {
		grid = new GridPane();
        grid.setAlignment(Pos.TOP_LEFT);
        grid.setHgap(H_PADDING_HELPSCREEN);
        grid.setVgap(V_PADDING_HELPSCREEN);
        grid.setPadding(INSET_GRID_DEFAULT);
        
		this.setPrefSize(WIDTH_PREFERRED_WINDOW, HEIGHT_PREFERRED_WINDOW);
		this.setContent(grid);
		
        Text scenetitle = new Text("Cheatsheet");
        scenetitle.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_TITLE));
        scenetitle.setFill(FONT_COLOR_DEFAULT);
        grid.add(scenetitle, X_POS_SCENE_TITLE, Y_POS_SCENE_TITLE);
        
        implementAddBoxes();
        implementDeleteBoxes();
        implementEditBoxes();
        implementDoneBoxes();
        implementSearchBoxes();
        implementViewBoxes();
        implementUndoBoxes();
        implementRedoBoxes();
        implementExitBoxes();
        implementShortcuts();

	}
	
	private GridPane getSizedGridPane(){
		GridPane gridPane = new GridPane();
		gridPane.setHgap(5);
		gridPane.setVgap(3);
		return gridPane;
	}
	
	private void implementShortcuts() {
		int currYPos = Y_POS_SHORTCUTS_STARTING_POS;
		
        Text hiddenCalendarText = new Text("  :  Hidden-Calendar Mode");
        hiddenCalendarText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        hiddenCalendarText.setFill(FONT_COLOR_DEFAULT);
		GridPane addPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("F1");
        addPane.add(nameBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        addPane.add(hiddenCalendarText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(addPane, X_POS_STACKPANE , currYPos++);
        
        Text cheatSheetText = new Text("  :  Cheat Sheet");
        cheatSheetText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        cheatSheetText.setFill(FONT_COLOR_DEFAULT);
		GridPane cheatPane = getSizedGridPane();
        IndexBox cheatBox = new IndexBox("F2");
        cheatPane.add(cheatBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        cheatPane.add(cheatSheetText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(cheatPane, X_POS_STACKPANE , currYPos++);
        
        Text minimizedText = new Text("  :  Minimize Program");
        minimizedText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        minimizedText.setFill(FONT_COLOR_DEFAULT);
		GridPane minimizedPane = getSizedGridPane();
        IndexBox minimizedBox = new IndexBox("F3");
        minimizedPane.add(minimizedBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        minimizedPane.add(minimizedText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(minimizedPane, X_POS_STACKPANE , currYPos++);
        
        Text truncatedText = new Text("  :  Task Name Truncation");
        truncatedText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        truncatedText.setFill(FONT_COLOR_DEFAULT);
		GridPane truncatedPane = getSizedGridPane();
        IndexBox truncatedBox = new IndexBox("F4");
        truncatedPane.add(truncatedBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        truncatedPane.add(truncatedText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(truncatedPane, X_POS_STACKPANE , currYPos++);
        
        Text lengthenText = new Text("  :  Lengthen Window");
        lengthenText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        lengthenText.setFill(FONT_COLOR_DEFAULT);
		GridPane lengthenPane = getSizedGridPane();
        IndexBox lengthenBox = new IndexBox("F5");
        lengthenPane.add(lengthenBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        lengthenPane.add(lengthenText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(lengthenPane, X_POS_STACKPANE , currYPos++);
        
        Text shortenText = new Text("  :  Shorten Window");
        shortenText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        shortenText.setFill(FONT_COLOR_DEFAULT);
		GridPane shortenPane = getSizedGridPane();
        IndexBox shortenBox = new IndexBox("F6");
        shortenPane.add(shortenBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        shortenPane.add(shortenText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(shortenPane, X_POS_STACKPANE , currYPos++);
        
        Text normalViewText = new Text("  :  View Normal View");
        normalViewText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        normalViewText.setFill(FONT_COLOR_DEFAULT);
		GridPane normalViewPane = getSizedGridPane();
        IndexBox normalViewBox = new IndexBox("F7");
        normalViewPane.add(normalViewBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        normalViewPane.add(normalViewText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(normalViewPane, X_POS_STACKPANE , currYPos++);       
        
        Text overdueText = new Text("  :  View Overdue Tasks");
        overdueText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        overdueText.setFill(FONT_COLOR_DEFAULT);
		GridPane overduePane = getSizedGridPane();
        IndexBox overdueBox = new IndexBox("F8");
        overduePane.add(overdueBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        overduePane.add(overdueText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(overduePane, X_POS_STACKPANE , currYPos++);
        
        Text allViewText = new Text("  :  View All Tasks");
        allViewText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SCENE_BOX_CONTENTS));
        allViewText.setFill(FONT_COLOR_DEFAULT);
		GridPane allViewPane = getSizedGridPane();
        IndexBox allViewBox = new IndexBox("F9");
        allViewPane.add(allViewBox, X_POS_ICONBOX, Y_POS_ICONBOX);
        allViewPane.add(allViewText, X_POS_TEXT_IN_GRID, Y_POS_TEXT_IN_GRID);
        grid.add(allViewPane, X_POS_STACKPANE , currYPos++);
	}
	
	private void implementAddBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("+");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Add: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();
        
		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" add ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Event Name>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle2 = createColoredBox(",<Event Date>");
        addPane.add(commandRectangle2, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle3 = createColoredBox(",<Event Time>");
        addPane.add(commandRectangle3, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private void implementDeleteBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("-");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Delete: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" del ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Event Date>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle2 = createColoredBox(",<Event Index>");
        addPane.add(commandRectangle2, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private void implementEditBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("âœŽ");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Edit: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" del ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Event Date>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle2 = createColoredBox(",<Event Index>");
        addPane.add(commandRectangle2, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private void implementDoneBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("âœ“");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Done: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" del ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Event Date>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle2 = createColoredBox(",<Event Index>");
        addPane.add(commandRectangle2, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private void implementSearchBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("ðŸ”?");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Search: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" search ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Keyword>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private void implementViewBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("ðŸ‘“");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("View: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" view ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);
        StackPane commandRectangle1 = createColoredBox("<Date(s)>");
        addPane.add(commandRectangle1, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	

	private void implementUndoBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("â†?");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Undo: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" undo ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	

	private void implementRedoBoxes() {
		GridPane labelPane = getSizedGridPane();
        IndexBox nameBox = new IndexBox("â†’");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Redo: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle2 = createColoredBox(" redo ");
        addPane.add(commandRectangle2, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	

	private void implementExitBoxes() {
		GridPane labelPane = getSizedGridPane();
		
        IndexBox nameBox = new IndexBox("X");
        labelPane.add(nameBox, X_POS_NAMEBOX, Y_POS_NAMEBOX);
        Text addText = new Text("Exit: ");
        addText.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_COMMANDS_TEXTS));
        addText.setFill(FONT_COLOR_DEFAULT);
        labelPane.add(addText, X_POS_DESCRIPTION_BOX, Y_POS_DESCRIPTION_BOX);
        
		GridPane addPane = getSizedGridPane();

		int currXpos = X_POS_START_TEXTBOX_CHUNKS;
        StackPane commandRectangle = createColoredBox(" exit ");
        addPane.add(commandRectangle, currXpos++, Y_POS_TEXTBOX_CHUNKS);

        grid.add(labelPane, X_POS_LABEL_PANE, currentYPosition);
        grid.add(addPane, X_POS_DESCRIPTION_PANE, currentYPosition++);
	}
	
	private StackPane createColoredBox(String boxText) {
		StackPane stackPane = new StackPane();
		Rectangle box = new Rectangle();
		
		int textLength = boxText.length();
		int boxWidth = textLength*MULTIPLIER_BOX_TO_TEXT_SIZE;
		
		box.setWidth(boxWidth);
		box.setHeight(HEIGHT_ENTIRE_BOX);
		box.setArcWidth(ARC_ENTIRE_BOX);
		box.setArcHeight(ARC_ENTIRE_BOX);               
		box.setStroke(FONT_COLOR_DEFAULT);
		box.setStrokeWidth(SIZE_STROKE_WIDTHS);
		box.setFill(Color.LIGHTGREY);

		Text text = new Text(boxText);
		text.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_SHORTCUTS));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(FONT_COLOR_DEFAULT);
		
		stackPane.getChildren().addAll(box, text);
		
		return stackPane;
	}
}
```
###### src\userinterface\IndexBox.java
``` java
package userinterface;

import common.TaskType;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

public class IndexBox extends StackPane{
	//For styling of the font
	private static int FONTSIZE_DEFAULT = 13;
	private static Color[] COLOR_ARRAY_BOX = {(Color.web("D652FF")), Color.web("6495ED"), 
			(Color.web("51D444")), (Color.web("D4573A")), (Color.POWDERBLUE)};
	private static String FONT_TYPE = "Tahoma";

	//These dimensions size the IndexBoxes correctly
	private static int BOX_WIDTH_HEIGHT_DEFAULT = 20;
	private static int BOX_ARC_SIZE_DEFAULT = 4;
	private static float BOX_STROKE_SIZE_DEFAULT = 2.0f;
	
	//Constructor for colored box according to task type
	public IndexBox(int index, TaskType inputTaskType) {
		
		Rectangle box = new Rectangle();
		box.setWidth(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setHeight(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setArcWidth(BOX_ARC_SIZE_DEFAULT);
		box.setArcHeight(BOX_ARC_SIZE_DEFAULT);               
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(BOX_STROKE_SIZE_DEFAULT);

		switch (inputTaskType) {
		case FLOATING:
			box.setFill(COLOR_ARRAY_BOX[0]);
			break;
		case EVENT:
			box.setFill(COLOR_ARRAY_BOX[1]);
			break;
		case TODO:
			box.setFill(COLOR_ARRAY_BOX[2]);
			break;
		default:
			box.setFill(COLOR_ARRAY_BOX[3]);
			break;
		}
		
		Text text = new Text(Integer.toString(index));
		text.setFont(Font.font(FONT_TYPE, FontWeight.BOLD, FONTSIZE_DEFAULT));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(Color.WHITE);
		
		if (index==0) {
			text.setText("");
		}
		this.getChildren().addAll(box, text);
		
	}
	
	//Constructor for RED index box
	public IndexBox () {		
		Rectangle box = new Rectangle();
		box.setWidth(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setHeight(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setArcWidth(BOX_ARC_SIZE_DEFAULT);
		box.setArcHeight(BOX_ARC_SIZE_DEFAULT);               
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(BOX_STROKE_SIZE_DEFAULT);
		
		Text text = new Text();
		text.setFont(Font.font(FONT_TYPE, FontWeight.BOLD, FONTSIZE_DEFAULT));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(Color.WHITE);
		text.setText("!");
		box.setFill(Color.RED);

		this.getChildren().addAll(box, text);
	}
	
	//Constructor for non-digit IndexBox
	public IndexBox (String textInput) {
		Rectangle box = new Rectangle();
		box.setWidth(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setHeight(BOX_WIDTH_HEIGHT_DEFAULT);
		box.setArcWidth(BOX_ARC_SIZE_DEFAULT);
		box.setArcHeight(BOX_ARC_SIZE_DEFAULT);               
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(BOX_STROKE_SIZE_DEFAULT);

		Text text = new Text(textInput);
		text.setFont(Font.font(FONT_TYPE, FontWeight.BOLD, FONTSIZE_DEFAULT));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(Color.WHITE);

		box.setFill(Color.DIMGRAY);
		this.getChildren().addAll(box, text);
	}
}
```
###### src\userinterface\PrettyDisplay.java
``` java
package userinterface;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.SortedMap;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.*;
import logic.Controller;
import common.*;
import java.util.logging.*;
 
public class PrettyDisplay extends Application {
	
	//Variables to help track current state of GUI
    private double currentScrollYPos = 0;
    private boolean isTruncatedMode = false;
    private int currentStageHeight = HEIGHT_STAGE_DEFAULT;
    
    //Instantiated objects that GUI uses and needs to point to at various instances
	Text sceneTitle = new Text(TITLE_CALENDAR_SCENE);
    Controller mainController;
    GridPane calendarGrid;
    GridPane programMainGrid;
    ScrollPane calendarScrollPane;
    TextField userTextField;
    Scene scene;
    Stage objPrimaryStage;
    ProgramState programState;
    FlowPane programFeedback;
    ConsoleInputColorizer colorizer;
    HelpScreen helpScreen = new HelpScreen();
    
    //Default strings used in various instances
    private static String TITLE_CALENDAR_SCENE = "                         To-Do List";
    private static String TITLE_HIDDEN_CALENDAR = "  Crouching Panther; Hidden Calendar";
    private static String STRING_INVALID_COMMAND = "Unrecognized command. Press PAGE_UP for Help Screen.";
    private static String STRING_DEFAULT_FEEDBACK = "Input command into the field below";
    private static String STRING_DEFAULT_PROGRAM_TITLE = "PinkPanther: The best to-do list";
    private static String STRING_LOGO_DIRECTORY = "PPLogo.png";
    private static String STRING_LOGO_DIRECTORY_ALT = "file:PPLogo.png";
    
    //Strings for logging
    private static String STRING_LOGGER_GUI_INSTANTIATED = "GUI successfully instantiated";
    private static String STRING_LOGGER_PROGRAM_STATE_UNPACKED = "All tasks unpacked from ProgramState";
    private static String STRING_LOGGER_ATTEMPT_EXECUTE = "Attempting to get Controller to execute command: ";
    private static String STRING_LOGGER_EXIT_CALLED = "Exit command called";
    
    //Default values for objects' positions and sizes in program window
    private static int HEIGHT_STAGE_DEFAULT = 1020;
    private static int OFFSET_SCREEN_PROGRAM_BUFFER = 10;
    private static int WIDTH_STAGE_DEFAULT = 1080;
    private static int YPOS_USER_INPUT_DEFAULT = 5;
    private static int YPOS_USER_FEEDBACK_DEFAULT = 2;
    private static int YPOS_TASK_INDICATOR_BOX = 3;
    private static int XPOS_TASK_INDICATOR_BOX = 55;
    private static int PARAMETER_GRID_GAP = 1;
    private static Insets PADDING_CALENDAR_GRID = new Insets(10, 10, 10, 10);
    private static Insets PADDING_MAIN_GRID = new Insets(25, 25, 25, 25);
    private static int WIDTH_PROGRAM_DEFAULT = 720;
    private static int POSITION_DEFAULT_X_LEFT = 0;
    private static int POSITION_DEFAULT_X_CENTRE = 1;
    private static int POSITION_DEFAULT_Y_FIRST_ITEM = 0;
    private static int HEIGHT_HIDDEN_CALENDAR = 200;
    private static int FONTSIZE_SCENE_TITLE = 33;
    private static float AMOUNT_SCROLL_PER_CLICK = 0.25f;
    private static int OFFSET_X_POS_CLASH_INDICATOR = 3;
    private static int OFFSET_Y_POS_CLASH_INDICATOR = 1;
    private static int STEP_PROGRAM_HEIGHT_CHANGE = 30;
    private static int HEIGHT_MINIMUM_PROGRAM = 210;
    private static int HGAP_MINI_TASK_INDICATORS = 10;
    private static int VGAP_MINI_TASK_INDICATORS = 5;
    
    //Enumerator and state to note which state the program is in
    private enum CurrentState {VIEWING_CALENDAR, VIEWING_HELPSCREEN, VIEWING_HIDDEN}
    private CurrentState currentState = CurrentState.VIEWING_CALENDAR;
    private static Logger logger = Logger.getLogger("PrettyDisplay");
    
    public static void main(String [] args) {
    	launch();
    }
    
    /*
     * start() initiates the whole program at runtime. It creates the controller class,
     * which then instantiates all other objects the program needs
     */
    @Override
    public void start(Stage primaryStage) {
    	objPrimaryStage = primaryStage;
    	mainController = new Controller();
    	implementSceneObjects();
        setStage(primaryStage);
        logger.log(Level.INFO, STRING_LOGGER_GUI_INSTANTIATED);
    }
    
    private void implementSceneObjects(){
    	setProgramHeightToUserScreen();
    	objPrimaryStage.setTitle(STRING_DEFAULT_PROGRAM_TITLE);
    	loadImageIcon();
        //Holds all calendar items
        implementCalendarGrid();
        //Holds content of Grid together with grid1
        implementScrollPane();
        //Holds calendar grid and textboxes/buttons below
        implementMainGrid();
        //Holds the user input box
        implementUserTextField();
        //Text that displays after-action (e.g added x event)
        implementUserFeedback("Input command in the field above"); // to remove
        //Set feedback to default string
        setUserFeedback(parseAndColorize(STRING_DEFAULT_FEEDBACK));
        //Allows keyboard inputs to be read as commands
        implementKeystrokeEvents(objPrimaryStage);
        //Implements the scene
        implementScene();
    }
    
    private void loadImageIcon(){
    	try{
	    	Image logoImage = new Image(STRING_LOGO_DIRECTORY);
	    	objPrimaryStage.getIcons().add(logoImage);
    	} catch (Exception e){
    		Image logoImage = new Image(STRING_LOGO_DIRECTORY_ALT);
	    	objPrimaryStage.getIcons().add(logoImage);
    	}
    }
    
    private void setProgramHeightToUserScreen() {
    	Rectangle2D primScreenBounds = Screen.getPrimary().getVisualBounds();
        setCurrentStageHeight((int) (primScreenBounds.getHeight() - OFFSET_SCREEN_PROGRAM_BUFFER));
    }

    //Implements main Grid: Holds contents for the Calendar
    private void implementCalendarGrid() {    
        calendarGrid = new GridPane();
        calendarGrid.setAlignment(Pos.TOP_LEFT);
        calendarGrid.setHgap(PARAMETER_GRID_GAP);
        calendarGrid.setVgap(PARAMETER_GRID_GAP);
        calendarGrid.setPadding(PADDING_CALENDAR_GRID);
        populateGrid(calendarGrid);	
    }
    //calendarScrollPane holds mainCalendarGrid
    private void implementScrollPane() {
    	calendarScrollPane = new ScrollPane();
        calendarScrollPane.setPrefSize(WIDTH_STAGE_DEFAULT, HEIGHT_STAGE_DEFAULT);
        calendarScrollPane.setContent(calendarGrid);
        calendarScrollPane.setStyle("-fx-background-color: transparent;");
    }
    //mainGrid holds all other grids in the program
    private void implementMainGrid() {
        programMainGrid = new GridPane();
        programMainGrid.setAlignment(Pos.TOP_LEFT);
        programMainGrid.setHgap(PARAMETER_GRID_GAP);
        programMainGrid.setVgap(PARAMETER_GRID_GAP);
        programMainGrid.setPadding(PADDING_MAIN_GRID);
        programMainGrid.add(calendarScrollPane,POSITION_DEFAULT_X_LEFT, POSITION_DEFAULT_Y_FIRST_ITEM);
        
    }
    //UserTextField is the text box that the user types in
    private void implementUserTextField() {
        userTextField = new TextField();
        userTextField.setStyle(""
        + "-fx-font-size: 17px;"
        + "-fx-font-weight: bold;"
        + "-fx-font-family: Tahoma;"
        + "-fx-text-fill: BLACK;"
        + "-fx-border-width: 6px;"
        + "-fx-border-color: DIMGRAY;"
        + "-fx-background-color: WHITE");
        programMainGrid.add(userTextField, POSITION_DEFAULT_X_LEFT, YPOS_USER_INPUT_DEFAULT);
    }
    //UserFeedback is the text that displays messages to the user, above the input box
    private void implementUserFeedback(String newInput) {
        programFeedback = new FlowPane();
        programMainGrid.add(programFeedback, POSITION_DEFAULT_X_LEFT, YPOS_USER_FEEDBACK_DEFAULT);
        colorizer = new ConsoleInputColorizer();
        colorizer.setController(mainController);
    }
    //This function allows program to handle keyboard presses by the user
    private void implementKeystrokeEvents(Stage primaryStage) {
        userTextField.setOnKeyPressed(
        		new EventHandler<KeyEvent>()
			        {
			            @Override
			            public void handle(KeyEvent ke)
			            {
			            	executeKeypress(ke, primaryStage);
			            }
			        });
    }
    //Sets scene to correct dimensions
    private void implementScene() {
        scene = new Scene(programMainGrid, WIDTH_PROGRAM_DEFAULT, HEIGHT_STAGE_DEFAULT);
        scene.getStylesheets().clear();
        scene.getStylesheets().add(this.getClass().getResource("PinkPanther.css").toExternalForm());
    }
    //Sets stage to correct dimensions
    private void setStage(Stage primaryStage) {
        primaryStage.setResizable(false);
        primaryStage.setScene(scene);
        primaryStage.show();
        setStageHeight();
    }
    private void setStageHeight() {
		objPrimaryStage.setHeight(getCurrentStageHeight());
	}
    private void setScrollPaneHeight() {
        calendarScrollPane.setPrefSize(WIDTH_STAGE_DEFAULT, getCurrentStageHeight());
		objPrimaryStage.setHeight(getCurrentStageHeight());
	}
	
	/* Function adds all needed objects to the scene
	 * This function is called whenever the calendar switches view or
	 * needs to refresh due to a change in calendar items
	 */
    private void populateGrid(GridPane grid) {
        sceneTitle.setFont(Font.font("Tahoma", FontWeight.BOLD, FONTSIZE_SCENE_TITLE));
        sceneTitle.setFill(Color.DIMGRAY);
        grid.add(sceneTitle, POSITION_DEFAULT_X_CENTRE, POSITION_DEFAULT_Y_FIRST_ITEM);
        
        try{
        	sceneTitle.setText(programState.getTitle());
        } catch (NullPointerException e) {
        	sceneTitle.setText(TITLE_CALENDAR_SCENE);
        }
        
    	programState = mainController.getProgramState();
    	setUserTextField(programState.getInputBoxText());
    	unpackTasks(grid);
    }
    
    /* Function has 3 unpack calls, one for overdueTasks, another for floatingTasks,
     * and the last for datedTasks.
     */
    private void unpackTasks(GridPane grid) {
    	int currTaskIndex = 1;
    	int currentYPos = 1;
    	
    	if (programState != null) {
    		currentYPos = displayNumOverdueTasks(grid, currTaskIndex, currentYPos);
        	currentYPos = unpackFloatingTasks(grid, currTaskIndex, currentYPos);
        	currentYPos = unpackDatedTasks(grid, currTaskIndex, currentYPos);
    	}

        logger.log(Level.INFO, STRING_LOGGER_PROGRAM_STATE_UNPACKED);
    }
    
    //Function requests for the list of Overdue tasks from ProgramState and adds them to calendar grid
    private int displayNumOverdueTasks(GridPane grid, int currTaskIndex, int currentYPos) {
		if (programState.getTitle().equals(TITLE_CALENDAR_SCENE)) {
	    	SortedMap<LocalDate,ArrayList<Task>> overdueList = programState.getOverdueList();
	    	if (overdueList != null) {
	    		grid.add(new TransparentCircle(), POSITION_DEFAULT_X_CENTRE, currentYPos++);
	    		int numOverdueTasks = 0;
	    		for(LocalDate date:overdueList.keySet()) {
	    			for(@SuppressWarnings("unused") Task task:overdueList.get(date)) { 
	    				numOverdueTasks++;
	    			}
	    		}
	    		
	    		if (numOverdueTasks > 0) {
		    		currentYPos++;
		    		TaskBox overdueTaskReminder = new TaskBox(numOverdueTasks + " OVERDUE TASKS : CLICK F8 TO VIEW ");
					currTaskIndex++;
		    		grid.add(overdueTaskReminder, POSITION_DEFAULT_X_CENTRE, currentYPos);
		    		currentYPos++;
	    		}
	    	}
		}
    	return currentYPos;
    }

    //Function requests for the list of Undated(floating) tasks from ProgramState and adds them to calendar grid
    private int unpackDatedTasks(GridPane grid, int currTaskIndex, int currentYPos) {
    	//for unpacking datedTasks
    	SortedMap<LocalDate,ArrayList<Task>> todoList = programState.getTodoList();
    	if (todoList != null) {
	    	for(LocalDate date:todoList.keySet()) { //looping through dates which have Tasks inside
	    		int totalDeadline = 0, totalEvent = 0, totalTodo = 0;
	    		
	    		grid.add(new TransparentCircle(), POSITION_DEFAULT_X_CENTRE, currentYPos++);
	    		String month = date.getMonth().toString();
	    		month = month.substring(0, POSITION_DEFAULT_X_CENTRE)+ month.substring(1, month.length()).toLowerCase();
	    		String year = String.valueOf(date.getYear() %100);
	    		String currDayNum = Integer.toString(date.getDayOfMonth());
	    		int currDayXPos = 1;
	    		DayBox dayBox = new DayBox(currDayNum + " " + month + " " +year);
	    		int dayBoxYPos = currentYPos;
	    		grid.add(dayBox, currDayXPos++, dayBoxYPos);
	    		currentYPos ++;
	    		int currXPos = 1;
	    		currTaskIndex = 1;
	    		
	    		//count total number of tasks of particular types
				for(Task task:todoList.get(date)) { 
					switch(task.getTaskType()) {
						case DEADLINE:
							totalDeadline++;
							break;
						case TODO:
							totalTodo++;
							break;
						default:
							totalEvent++;
							break;
					}
					if (task.getClash()) {
						IndexBox clashIndicatorBox = new IndexBox();
						grid.add(clashIndicatorBox, currXPos + OFFSET_X_POS_CLASH_INDICATOR, 
								currentYPos + OFFSET_Y_POS_CLASH_INDICATOR);
					}
					
		    		currentYPos++;
	    			TaskBox taskBox = new TaskBox(currTaskIndex, task, isTruncatedMode);
	    			currTaskIndex++;
		    		grid.add(taskBox, currXPos, currentYPos);
				}
				
				GridPane miniTaskIndicators = new GridPane();
				miniTaskIndicators.setHgap(HGAP_MINI_TASK_INDICATORS);
				miniTaskIndicators.setVgap(VGAP_MINI_TASK_INDICATORS);
				currDayXPos = XPOS_TASK_INDICATOR_BOX;
	    		for (int i=0; i<3; i++) {
	    			if (i==0 && totalDeadline != 0) {
		    			IndexBox blankColoredBox = new IndexBox(totalDeadline, TaskType.DEADLINE);
		    			miniTaskIndicators.add(blankColoredBox, currDayXPos--, YPOS_TASK_INDICATOR_BOX);
	    			} else if (i==1 && totalTodo != 0) {
		    			IndexBox blankColoredBox = new IndexBox(totalTodo, TaskType.TODO);
		    			miniTaskIndicators.add(blankColoredBox, currDayXPos--, YPOS_TASK_INDICATOR_BOX);
	    			} else if (i==2 && totalEvent != 0) {
		    			IndexBox blankColoredBox = new IndexBox(totalEvent, TaskType.EVENT);
		    			miniTaskIndicators.add(blankColoredBox, currDayXPos--, YPOS_TASK_INDICATOR_BOX);
	    			}
	    		}
	    		grid.add(miniTaskIndicators, POSITION_DEFAULT_X_CENTRE, dayBoxYPos);
				currentYPos++;
			}
	    }
    	return currentYPos;
    }

    //Function requests for the list of Dated tasks from ProgramState and adds them to calendar grid
    private int unpackFloatingTasks(GridPane grid, int currTaskIndex, int currentYPos) {
    	//for unpacking floatingTasks
    	ArrayList<Task> floatingTasks = programState.getFloatingList();	
    	if (floatingTasks != null && floatingTasks.size() != 0) {
    		grid.add(new TransparentCircle(), POSITION_DEFAULT_X_CENTRE, currentYPos++);
    		int totalFloat = 0;

    		currentYPos++;
    		currentYPos++;
	    	int currFloatXPos = 1;
    		DayBox dayBox = new DayBox("Undated Tasks");
    		int dayTextYPos = currentYPos;
    		grid.add(dayBox, POSITION_DEFAULT_X_CENTRE, currentYPos++);
	    	for (int i=0; i<floatingTasks.size(); i++) {
	    		totalFloat++;
	    		currentYPos++;
	    		TaskBox taskBox = new TaskBox(i+1, floatingTasks.get(i), isTruncatedMode);
	    		currTaskIndex++;
	    		grid.add(taskBox, currFloatXPos, currentYPos);

	    	}

			GridPane miniTaskIndicators = new GridPane();
			miniTaskIndicators.setHgap(HGAP_MINI_TASK_INDICATORS);
			miniTaskIndicators.setVgap(VGAP_MINI_TASK_INDICATORS);
			IndexBox blankColoredBox = new IndexBox(totalFloat, TaskType.FLOATING);
			miniTaskIndicators.add(blankColoredBox, XPOS_TASK_INDICATOR_BOX, dayTextYPos);
			grid.add(miniTaskIndicators, POSITION_DEFAULT_X_CENTRE, dayTextYPos);
	    	currentYPos++;
    	}
    	
    	return currentYPos;
    }

    //Function calls Logic to process a command by user or this class itself
    private void callControllerToAddCommand() {
    	String command = userTextField.getText();
        logger.log(Level.INFO, STRING_LOGGER_ATTEMPT_EXECUTE + command);
    	mainController.addCommand(command);
    	setUserFeedback();
    	calendarGrid.getChildren().clear();
    	sceneTitle.setText(programState.getTitle());
        populateGrid(calendarGrid);
        if(mainController.getProgramState().getExitState()) {
        	closeWindow();
        }
    }
    
    //This function transforms a string of text to a colorized FlowPane
    private FlowPane parseAndColorize(String text) {
    	if (text.equals("INVALID")) {
    		text = STRING_INVALID_COMMAND;
    	}
    	FlowPane colorizedText = colorizer.parseInputToArray(text);
    	return colorizedText;
    }
    
    //Sets userFeedBack. Input must be parsed through parseAndColorize() function first.
    private void setUserFeedback(FlowPane feedback) {
    	if (!programMainGrid.getChildren().remove(programFeedback)) {
    		if (currentState != CurrentState.VIEWING_HELPSCREEN) {
    			programMainGrid.getChildren().remove(2);
    		}
    	}
    	programFeedback = feedback;
    	programMainGrid.add(programFeedback , POSITION_DEFAULT_X_LEFT, YPOS_USER_FEEDBACK_DEFAULT);
    }
    
  //Sets userFeedBack as STRING_DEFAULT_FEEDBACK
    private void setUserFeedback() {
    	FlowPane feedback;
    	if (Display.showFeedBack() != null) {
    		feedback = parseAndColorize(Display.showFeedBack());
    	} else {
    		feedback = parseAndColorize(STRING_DEFAULT_FEEDBACK);
    	}
    	
    	setUserFeedback(feedback);
    }
    
    //Changes the text currently in user's input box
    private void setUserTextField(String text) {
    	if(userTextField!=null) {
    		userTextField.setText(text);
    		userTextField.positionCaret(text.length());
    	}
    }
    
    private void clearTextField() {
    	userTextField.clear();
    }
	
    //Function handles all keyboard presses accordingly
    private void executeKeypress(KeyEvent ke, Stage stage) {
		Stage primaryStage = stage;
		
		if (ke.getCode().equals(KeyCode.ENTER)) {
			processUserEnter();
        }
        
        else if (ke.getCode().equals(KeyCode.DOWN)) {
    		scrollDown(AMOUNT_SCROLL_PER_CLICK);
        }
        else if (ke.getCode().equals(KeyCode.UP)) {
    		scrollUp(AMOUNT_SCROLL_PER_CLICK);
        }
        else if (ke.getCode().equals(KeyCode.F2)) {
        	attemptToggleHelpScreenView();
        }
        else if (ke.getCode().equals(KeyCode.PAGE_UP) || ke.getCode().equals(KeyCode.F6)) {
        	if (getCurrentStageHeight() > HEIGHT_MINIMUM_PROGRAM) {
        		setCurrentStageHeight(getCurrentStageHeight() - STEP_PROGRAM_HEIGHT_CHANGE);
        	}
        	setScrollPaneHeight();
        	setStageHeight();
        }
        else if (ke.getCode().equals(KeyCode.PAGE_DOWN) || ke.getCode().equals(KeyCode.F5)) {
        	if (getCurrentStageHeight() < HEIGHT_STAGE_DEFAULT + STEP_PROGRAM_HEIGHT_CHANGE) {
        		setCurrentStageHeight(getCurrentStageHeight() + STEP_PROGRAM_HEIGHT_CHANGE);
        	}
        	setScrollPaneHeight();
        	setStageHeight();
        }
        else if (ke.getCode().equals(KeyCode.ESCAPE) || ke.getCode().equals(KeyCode.F3)) {
        	//minimize program to tray
            primaryStage.setIconified(true);
        }
        else if (ke.getCode().equals(KeyCode.F1)) {
        	if (currentState == CurrentState.VIEWING_HELPSCREEN) {
	        	attemptToggleHelpScreenView();
			}
        	attemptToggleCalendarHiddenMode(stage);
        } 
        else if (ke.getCode().equals(KeyCode.F4) && currentState == CurrentState.VIEWING_CALENDAR) {
        	isTruncatedMode = !isTruncatedMode;
        	calendarGrid.getChildren().clear();
        	sceneTitle.setText(programState.getTitle());
            populateGrid(calendarGrid);
        }
        else if (ke.getCode().equals(KeyCode.BACK_SPACE)) {
        	processBackSpace();
        }
		

        else if (ke.getCode().equals(KeyCode.F7)) {
			userTextField.setText("view normal");
			callControllerToAddCommand();
			if (currentState == CurrentState.VIEWING_HELPSCREEN) {
	        	attemptToggleHelpScreenView();
			}
        }
        else if (ke.getCode().equals(KeyCode.F8)) {
			userTextField.setText("view overdue");
			callControllerToAddCommand();
			if (currentState == CurrentState.VIEWING_HELPSCREEN) {
	        	attemptToggleHelpScreenView();
			}
        }
        else if (ke.getCode().equals(KeyCode.F9)) {
			userTextField.setText("view all");
			callControllerToAddCommand();
			if (currentState == CurrentState.VIEWING_HELPSCREEN) {
	        	attemptToggleHelpScreenView();
			}
        }
        
        else if (ke.getCode().isLetterKey() ||  ke.getCode().isDigitKey() || ke.getCode().equals(KeyCode.SPACE)) {
        	//for all other non-reserved keystrokes
        	processNonReservedKeys(ke);
        }
		
	}
	
    private void processBackSpace() {
    	String userText = userTextField.getText();
    	
    	if (userText.length() <= 1) {
    		userText = STRING_DEFAULT_FEEDBACK;
		} else {
    		userText = userText.substring(0, userText.length()-1);
    	}
    	
    	FlowPane colorizedText = parseAndColorize(userText);
    	setUserFeedback(colorizedText);
	}
	
    private void processNonReservedKeys(KeyEvent ke) {
    	String userText = userTextField.getText();
    	
    	if (ke.getCode().isLetterKey()) {
    		userText = userText + ke.getCode().toString().toLowerCase();
    	} else if (ke.getCode().isDigitKey()) {
    		userText = userText + ke.getCode().getName();
    	} else if (ke.getCode().equals(KeyCode.SPACE)) {
    		userText = userText + " ";
    	}
    	
    	FlowPane colorizedText = parseAndColorize(userText);
    	setUserFeedback(colorizedText);
	}
	
	//Called when user presses ENTER button, and processes text in input box accordingly
    private void processUserEnter() {
    	if ((userTextField.getText() != null && !userTextField.getText().isEmpty())) {
			callControllerToAddCommand();
        }
	}
	
    private void scrollUp(double scrollValue) {
		switch (currentState) {
		case VIEWING_CALENDAR: 
			calendarScrollPane.setVvalue(calendarScrollPane.getVvalue() - scrollValue);
			break;
		default:
			helpScreen.setVvalue(helpScreen.getVvalue() - scrollValue);
			break;
		}
	}
    private void scrollDown(double scrollValue) {
		switch (currentState) {
		case VIEWING_CALENDAR: 
			calendarScrollPane.setVvalue(calendarScrollPane.getVvalue() + scrollValue);
			break;
		default:
			helpScreen.setVvalue(helpScreen.getVvalue() + scrollValue);
			break;
		}
	}
	
    private void attemptToggleHelpScreenView() {
		if (currentState != CurrentState.VIEWING_HIDDEN) {
			if (currentState == CurrentState.VIEWING_CALENDAR) {
				viewHelpScreen();
			} else if (currentState == CurrentState.VIEWING_HELPSCREEN) {
				hideHelpScreen();
			}
		}
	}
	
	//Shifts program to CheatSheet screen. Only accessible in Calendar mode.
    private void viewHelpScreen() {
    	programMainGrid.getChildren().remove(calendarScrollPane);
    	programMainGrid.add(helpScreen, POSITION_DEFAULT_X_LEFT, POSITION_DEFAULT_Y_FIRST_ITEM);
		currentState = CurrentState.VIEWING_HELPSCREEN;
	}

	//Shifts program back to Calendar screen from CheatSheet screen.
    private void hideHelpScreen() {
		programMainGrid.getChildren().clear();
		programMainGrid.add(calendarScrollPane,POSITION_DEFAULT_X_LEFT, POSITION_DEFAULT_Y_FIRST_ITEM);
        programMainGrid.add(userTextField, POSITION_DEFAULT_X_LEFT, YPOS_USER_INPUT_DEFAULT);
        setUserFeedback();
		currentState = CurrentState.VIEWING_CALENDAR;
	}

    private void attemptToggleCalendarHiddenMode(Stage stage) {
		if (currentState == CurrentState.VIEWING_CALENDAR) {
			hideCalendar(stage);
		} else if (currentState == CurrentState.VIEWING_HIDDEN) {
			unHideCalendar(stage);
		}
	}
	
	//Restores screen back to last configured height and unhides calendar
    private void unHideCalendar(Stage stage) {
        stage.setHeight(getCurrentStageHeight());
        sceneTitle.setText(programState.getTitle());
        calendarScrollPane.setDisable(false);
 		calendarScrollPane.setVvalue(currentScrollYPos);
		currentState = CurrentState.VIEWING_CALENDAR;
	}
	
	//Downsizes window and hides calendar, locking scrollbar.
	//Can only be accessed in Calendar mode
    private void hideCalendar(Stage stage) {
		if (currentState != CurrentState.VIEWING_HELPSCREEN) {
	    stage.setHeight(HEIGHT_HIDDEN_CALENDAR);
	    sceneTitle.setText(TITLE_HIDDEN_CALENDAR);
	    calendarScrollPane.setDisable(true);
	    calendarScrollPane.setVvalue(0);
		currentState = CurrentState.VIEWING_HIDDEN;
		}
	}

	private void closeWindow() {
        logger.log(Level.INFO, STRING_LOGGER_EXIT_CALLED);
		Platform.exit();
	}

	private int getCurrentStageHeight() {
		return currentStageHeight;
	}

	private void setCurrentStageHeight(int currentStageHeight) {
		this.currentStageHeight = currentStageHeight;
	}


}
```
###### src\userinterface\TaskBox.java
``` java
package userinterface;

import common.Task;
import common.TaskType;
import javafx.geometry.Insets;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

public class TaskBox extends StackPane{
	private static int MAX_LENGTH_TASKNAME = 45;
	
	//These coordinates help position items on grid
	private static int POSITION_MAIN_BOX_X_POS = 1;
	private static int POSITION_DEFAULT_Y_COORD = 1;
	private static int POSITION_TIMESPAN_START_BOX = 65;
	private static int POSITION_DEFAULT_LEFT_ALIGNED_X_COORD = 0;
	private static int POSITION_DEFAULT_CENTRE_ALIGNED_X_COORD = 1;
	private static int POSITION_DEFAULT_RIGHT_ALIGNED_X_COORD = 2;
	private static int SIZE_PADDING_GRID_H = 5;
	private static int SIZE_PADDING_GRID_V = 0;
	private static int SIZE_PADDING_TIMEBOX_V_GAP = 10;
	
	//These settings help set the font and text to align properly within the grid
	private static String DEFAULT_FONT_NAME = "Tahoma";
	private static int FONTSIZE_TASK_NAME = 20;
	private static int FONTSIZE_TIMESPAN_ARROW = 15;
	private static String OFFSET_TASK_NAME = "     ";
	private static String OFFSET_DEADLINE_INDICATOR = "by ";
	private static String OFFSET_TRUNCATED_DOTS = "...";

	//These settings help set the size and colors of the boxes
	private static int SIZE_WIDTH_TASKHOLDERBOX = 600;
	private static int SIZE_HEIGHT_TASKHOLDERBOX = 40;
	private static int SIZE_ARC_TASKHOLDERBOX = 4;
	private static int SIZE_WIDTH_AND_HEIGHT_INDEXBOX = 20;
	private static int SIZE_ARC_INDEXBOX = 4;
	private static float THICKNESS_DEFAULT_STROKE_WIDTH = 2.0f;
	private static Color COLOR_DEFAULT_TIMEBOX_COLOR = Color.DIMGRAY.deriveColor(0, 1.2, 1, 0.6);
	private static Color COLOR_DEFAULT_TASKNAME_COLOR = Color.web("212121");
	private static ColumnConstraints COLUMN_CONSTRAINTS_ROW2 = new ColumnConstraints(50, 150, 100);
	private static ColumnConstraints COLUMN_CONSTRAINTS_ROW1 = new ColumnConstraints(5);
	private static Color[] COLORS_ARRAY_TASKBOX = {(Color.web("EFBAFF")), (Color.web("C1D5F8")), 
			(Color.web("B9EEB4")), (Color.web("EEBCB0")), (Color.POWDERBLUE)};
	private static Color[] COLORS_ARRAY_INDEXBOX = {(Color.web("D652FF")), Color.web("6495ED"), 
			(Color.web("51D444")), (Color.web("D4573A")), (Color.RED)};
	
	
	//Constructor
	public TaskBox(int index, Task inputTask, boolean isTruncatedMode) {
		TaskType inputTaskType = inputTask.getTaskType();
		String[] splitName = splitTaskNameIntoArray(inputTask.getName(), inputTask, inputTaskType);
		int numOfColumnsName = splitName.length;
		
		GridPane grid = instantiateTaskGrid(index, inputTask, 
				isTruncatedMode, inputTaskType, numOfColumnsName, splitName);
		
		this.getChildren().addAll(grid);
	}
	
	/* Breaks all input information down and constructs a GridPane and returns it
	 * 
	 * @param index: Index of task, numOfColumnsName: Number of columns the name occupies in total
	 * 			splitName: Task name split into String array
	 * 
	 * @return GridPane with all Task information displayed
	 */
	private GridPane instantiateTaskGrid(int index, Task inputTask, 
			boolean isTruncatedMode, TaskType inputTaskType, int numOfColumnsName, String[] splitName){
		GridPane grid = new GridPane();
		setGridConstraints(grid);
		addTaskNameRectangleToGrid(grid, inputTaskType, isTruncatedMode, numOfColumnsName);
		addNameTextToTaskBox(isTruncatedMode, splitName, numOfColumnsName, grid);
		addTimeBoxesToTaskBox(grid, index, numOfColumnsName, inputTask, inputTaskType);
		addIndexBoxToTaskBox(grid, index, inputTaskType);
		return grid;
	}
	private void addNameTextToTaskBox(boolean isTruncatedMode, String[] splitName, int numOfColumnsName, GridPane grid){
		int currYPos = 1;
		if (isTruncatedMode) {
			Text text = new Text(OFFSET_TASK_NAME + splitName[0]);
			if (numOfColumnsName > 1) {
				text.setText(text.getText() + OFFSET_TRUNCATED_DOTS);
			}
			text.setTextAlignment(TextAlignment.LEFT);
			text.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.NORMAL, FONTSIZE_TASK_NAME));
			text.setFill(COLOR_DEFAULT_TASKNAME_COLOR);
			grid.add(text, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, currYPos++);
		} else {
			for (int i=0; i<numOfColumnsName; i++) {
				Text text = new Text(OFFSET_TASK_NAME + splitName[i]);
				text.setTextAlignment(TextAlignment.LEFT);
				text.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.NORMAL, FONTSIZE_TASK_NAME));
				text.setFill(COLOR_DEFAULT_TASKNAME_COLOR);
				grid.add(text, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, currYPos++);
			}
		}
	}
	private void addIndexBoxToTaskBox(GridPane grid, int index, TaskType inputTaskType){
		if (index != 0) {
			StackPane indexBox = createIndexBox(index, inputTaskType);
			GridPane.setConstraints(indexBox , POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, 1);
			grid.add(indexBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
		}
	}
	private void addTimeBoxesToTaskBox(GridPane grid, int index, int numOfColumnsName, Task inputTask, TaskType inputTaskType){
		GridPane timeSpanBoxes = createTimeSpanBoxes(inputTask);
		int currRectYPos = 1;
		if (numOfColumnsName > 1 && inputTask.getTaskType() != TaskType.FLOATING) {
			Rectangle box = createTaskHolderBox(inputTaskType);
			grid.add(box, POSITION_DEFAULT_Y_COORD, currRectYPos++);
			grid.add(timeSpanBoxes, POSITION_TIMESPAN_START_BOX, currRectYPos -1);
		} else {
			grid.add(timeSpanBoxes, POSITION_TIMESPAN_START_BOX, POSITION_DEFAULT_Y_COORD);
		}
		
		if (index != 0) {
			StackPane indexBox = createIndexBox(index, inputTaskType);
			GridPane.setConstraints(indexBox , POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, 1);
			grid.add(indexBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
		}
	}
	private String[] splitTaskNameIntoArray(String taskName, Task inputTask, TaskType inputTaskType){
		String[] splitName;
		if (inputTaskType == TaskType.EVENT) {
			splitName = inputTask.getDisplayName(MAX_LENGTH_TASKNAME);
		} else {
			splitName = inputTask.getDisplayName(MAX_LENGTH_TASKNAME);
		}
		
		return splitName;
	}
	private void addTaskNameRectangleToGrid(GridPane grid, TaskType inputTaskType, boolean isTruncatedMode, int numOfColumnsName){
		int currRectYPos = 1;
		Rectangle mainBox = createTaskHolderBox(inputTaskType);
		grid.add(mainBox, POSITION_MAIN_BOX_X_POS, currRectYPos++);
		if (!isTruncatedMode) {
			for (int i=1; i<numOfColumnsName; i++) {
				Rectangle box = createTaskHolderBox(inputTaskType);
				grid.add(box, POSITION_MAIN_BOX_X_POS, currRectYPos++);
			}
		}
	}
	private void setGridConstraints(GridPane grid){
	    grid.setPadding(new Insets(SIZE_PADDING_GRID_H));
	    grid.setHgap(SIZE_PADDING_GRID_H);
	    grid.setVgap(SIZE_PADDING_GRID_V);

	    ColumnConstraints column1 = COLUMN_CONSTRAINTS_ROW1;
	    ColumnConstraints column2 = COLUMN_CONSTRAINTS_ROW2;
	    grid.getColumnConstraints().addAll(column1, column2);
	}
	
	/* Gets a task type and creates an appropriately colored rectangle
	 * @return appropriately colored Rectangle
	 */
	private Rectangle createTaskHolderBox(TaskType inputTaskType) {
		Rectangle box = new Rectangle();
		box.setWidth(SIZE_WIDTH_TASKHOLDERBOX);
		box.setHeight(SIZE_HEIGHT_TASKHOLDERBOX);
		box.setArcWidth(SIZE_ARC_TASKHOLDERBOX);
		box.setArcHeight(SIZE_ARC_TASKHOLDERBOX);                
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(0f);
		switch (inputTaskType) {
		case FLOATING:
			box.setFill(COLORS_ARRAY_TASKBOX[0]);
			break;
		case EVENT:
			box.setFill(COLORS_ARRAY_TASKBOX[1]);
			break;
		case TODO:
			box.setFill(COLORS_ARRAY_TASKBOX[2]);
			break;
		default:
			box.setFill(COLORS_ARRAY_TASKBOX[3]);
			break;
		
		}
		
		return box;
	}
	
	//@return a red box for misc uses
	private Rectangle createTaskHolderBox() {
		Color col = (Color.SALMON);
		Rectangle box = new Rectangle();
		box.setWidth(SIZE_WIDTH_TASKHOLDERBOX);
		box.setHeight(SIZE_HEIGHT_TASKHOLDERBOX);
		box.setArcWidth(SIZE_ARC_TASKHOLDERBOX);
		box.setArcHeight(SIZE_ARC_TASKHOLDERBOX);                
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(0f);
		box.setFill(col);
		return box;
	}
	
	/* Detects date ranges of a Task and creates a GridPane that
	 * holds Rectangles that display the time constraints of the task
	 * @return GridPane with colored boxes that display time constraints of task
	 */
	private GridPane createTimeSpanBoxes(Task inputTask) {
		GridPane timeSpanGridPane = new GridPane();
		timeSpanGridPane.setVgap(SIZE_PADDING_TIMEBOX_V_GAP);
		addStartTimeBox(timeSpanGridPane, inputTask);
		addEndTimeBox(timeSpanGridPane, inputTask);
		addTimespanArrow(timeSpanGridPane, inputTask);
		return timeSpanGridPane;
	}
	private void addTimespanArrow(GridPane timeSpanGridPane, Task inputTask){
		if (inputTask.getStartTime()!=null && inputTask.getEndTime()!=null) {
			Text dash = new Text("â–¸");
			dash.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.BOLD, FONTSIZE_TIMESPAN_ARROW));
			dash.setTextAlignment(TextAlignment.LEFT);
			dash.setFill(COLOR_DEFAULT_TIMEBOX_COLOR);
			
			timeSpanGridPane.add(dash, POSITION_DEFAULT_CENTRE_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
			
		}
	}
	private void addEndTimeBox(GridPane timeSpanGridPane, Task inputTask){
		if (inputTask.getEndTime()!= null) {
			TextedTimeBox timeBox;
			switch (inputTask.getTaskType()) {
			case DEADLINE:
				timeBox = new TextedTimeBox(OFFSET_DEADLINE_INDICATOR + inputTask.getEndTime().toString());
				break;
			default:
				timeBox = new TextedTimeBox(inputTask.getEndTime().toString());
				break;
			}
			timeSpanGridPane.add(timeBox, POSITION_DEFAULT_RIGHT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
		} else {
			TextedTimeBox startTimeBox = new TextedTimeBox("");
			timeSpanGridPane.add(startTimeBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);			
		}
	}
	private void addStartTimeBox(GridPane timeSpanGridPane, Task inputTask){
		if (inputTask.getStartTime()!= null) {
			TextedTimeBox startTimeBox = new TextedTimeBox(inputTask.getStartTime().toString());
			if (inputTask.getEndTime()!= null) {
				timeSpanGridPane.add(startTimeBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
			} else {
				timeSpanGridPane.add(startTimeBox, POSITION_DEFAULT_RIGHT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
			}
			
		} else {
			TextedTimeBox startTimeBox = new TextedTimeBox("");
			timeSpanGridPane.add(startTimeBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
		}
		
	}
	
	/* Gets the task index and its type, and creates an appropriately colored
	 * square with the index displayed in the middle.
	 * @return appropriately colored square with index displayed
	 */
	private StackPane createIndexBox(int index, TaskType inputTaskType) {
		
		StackPane stackPane = new StackPane();
		
		Rectangle box = new Rectangle();
		

		box.setWidth(SIZE_WIDTH_AND_HEIGHT_INDEXBOX);
		box.setHeight(SIZE_WIDTH_AND_HEIGHT_INDEXBOX);
		box.setArcWidth(SIZE_ARC_INDEXBOX);
		box.setArcHeight(SIZE_ARC_INDEXBOX);               
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(THICKNESS_DEFAULT_STROKE_WIDTH);

		switch (inputTaskType) {
		case FLOATING:
			box.setFill(COLORS_ARRAY_INDEXBOX[0]);
			break;
		case EVENT:
			box.setFill(COLORS_ARRAY_INDEXBOX[1]);
			break;
		case TODO:
			box.setFill(COLORS_ARRAY_INDEXBOX[2]);
			break;
		default:
			box.setFill(COLORS_ARRAY_INDEXBOX[3]);
			break;
		
		}
		Text text = new Text (String.valueOf(index));
		
		text.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.BOLD, 13));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(Color.WHITE);
		
		if (index == 0) {
			text.setText("");
		}
		stackPane.getChildren().addAll(box, text);
		
		return stackPane;
	}
	
	
	/*
	 * Bottom two constructors are for misc uses of TaskBox,
	 * to display non-task items in the same form as a TaskBox.
	 * Will return a RED box, with an indexBox marked '!'.
	 * For the use of OVERDUE TASKS.
	 */
	//created a red '!' indexbox for misc uses
	private StackPane createIndexBox() {
		Color col = (Color.RED);
		
		StackPane stackPane = new StackPane();
		
		Rectangle box = new Rectangle();
		box.setWidth(SIZE_WIDTH_AND_HEIGHT_INDEXBOX);
		box.setHeight(SIZE_WIDTH_AND_HEIGHT_INDEXBOX);
		box.setArcWidth(SIZE_ARC_INDEXBOX);
		box.setArcHeight(SIZE_ARC_INDEXBOX);               
		box.setStroke(Color.DIMGRAY);
		box.setStrokeWidth(THICKNESS_DEFAULT_STROKE_WIDTH);
		box.setFill(col);
		
		Text text = new Text ("!");
		text.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.BOLD, 13));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(Color.WHITE);
		
		stackPane.getChildren().addAll(box, text);
		
		return stackPane;
	}
	//Constructor for TaskBox for misc uses
	public TaskBox(String inputText) {
		String splitName = inputText;
		int currRectYPos = 1;
		
		GridPane grid = new GridPane();
		grid.setPadding(new Insets(5));
	    grid.setHgap(SIZE_PADDING_GRID_H);
	    grid.setVgap(SIZE_PADDING_GRID_V);

		Rectangle mainBox = createTaskHolderBox();
		grid.add(mainBox, POSITION_DEFAULT_Y_COORD, currRectYPos++);
		
	    ColumnConstraints column1 = COLUMN_CONSTRAINTS_ROW1;
	    ColumnConstraints column2 = COLUMN_CONSTRAINTS_ROW2;
	    grid.getColumnConstraints().addAll(column1, column2);
		
		int currYPos = 1;
		Text text = new Text(OFFSET_TASK_NAME + splitName);
		text.setTextAlignment(TextAlignment.LEFT);
		text.setFont(Font.font(DEFAULT_FONT_NAME, FontWeight.NORMAL, FONTSIZE_TASK_NAME));
		text.setFill(Color.WHITE);
		grid.add(text, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, currYPos++);
			
		StackPane indexBox = createIndexBox();
		grid.add(indexBox, POSITION_DEFAULT_LEFT_ALIGNED_X_COORD, POSITION_DEFAULT_Y_COORD);
		
		this.getChildren().addAll(grid);
	}
}

```
###### src\userinterface\TextedTimeBox.java
``` java
package userinterface;

import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

public class TextedTimeBox extends StackPane{
	
	//To adjust dimensions/color of box
	private int WIDTH_TIME_BOX = 80;
	private int HEIGHT_TIME_BOX = 20;
	private int ARC_TIME_BOX = 20;
	private Color BOX_COLOR_TRANSPARENT = Color.TRANSPARENT;
	private Color BOX_COLOR_DEFAULT = Color.DIMGRAY.deriveColor(0, 1.2, 1, 0.6);
	
	//To adjust size/color of text
	private int FONT_SIZE_DEFAULT = 15;
	private String FONT_TYPE_DEFAULT = "Tahoma";
	private Color FONT_COLOR_DEFAULT = Color.WHITE;
	
	//Constructor
	public TextedTimeBox(String time) {
		Rectangle box = createTimeBox();
		Text text = new Text(time);
		text.setFont(Font.font(FONT_TYPE_DEFAULT, FontWeight.BOLD, FONT_SIZE_DEFAULT));
		text.setTextAlignment(TextAlignment.CENTER);
		text.setFill(FONT_COLOR_DEFAULT);
		
		if (time.equals("")) {
			box.setFill(BOX_COLOR_TRANSPARENT);
		}
		this.getChildren().addAll(box, text);
	}
	
	//Create a colored rectangle to place Text inside
	private Rectangle createTimeBox() {
		Rectangle box = new Rectangle();
		box.setWidth(WIDTH_TIME_BOX);
		box.setHeight(HEIGHT_TIME_BOX);
		box.setArcWidth(ARC_TIME_BOX);
		box.setArcHeight(ARC_TIME_BOX);

        box.setFill(BOX_COLOR_DEFAULT);
        
        return box;
     } 
}
```
###### src\userinterface\TransparentCircle.java
``` java
package userinterface;

import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;

//This class creates some spacing in between grids, without altering gridV/H spacing attribute
public class TransparentCircle extends Rectangle{
	public TransparentCircle() {
        setWidth(20);
        setHeight(20);       
        setFill(Color.TRANSPARENT);
        setStroke(Color.TRANSPARENT);
        setStrokeWidth(4.0f);
     }  
}
```

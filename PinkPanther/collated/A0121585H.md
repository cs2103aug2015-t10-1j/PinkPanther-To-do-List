# A0121585H
###### src\common\Display.java
``` java
package common;

public class Display {
	private static String message;
	
	public static void setFeedBack(String feedback){
		message=feedback;
	}
	
	
	public static String showFeedBack(){
		return message;
	}
}
```
###### src\common\Pair.java
``` java
package common;

public class Pair<A,B> {
	private A first;
	private B second;
	
	public Pair(A input1, B input2){
		this.first=input1;
		this.second=input2;
	}
	
	public void setFirst(A input){
		this.first=input;
	}
	
	public void setSecond(B input){
		this.second=input;
	}
	
	public A getFirst(){
		return first;
	}
	
	public B getSecond(){
		return second;
	}
}
```
###### src\common\ProgramState.java
``` java
package common;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.SortedMap;
import java.util.TreeMap;

public class ProgramState {
	private ArrayList<Task>floatingList;
	private SortedMap<LocalDate,ArrayList<Task>>todoList;
	private SortedMap<LocalDate,ArrayList<Task>>overdue;
	private String title;
	private String inputBoxText;
	private boolean isExit;
	
	public ProgramState(){
		this.floatingList = new ArrayList<Task>();
		this.todoList = new TreeMap<LocalDate,ArrayList<Task>>();
		this.overdue = new TreeMap<LocalDate,ArrayList<Task>>();
		this.inputBoxText = "";
		this.isExit = false;
		this.title = "                         To-Do List";
	}
	
	public void setFLoatingList(ArrayList<Task>floatingList){
		this.floatingList=floatingList;
	}
	
	public void setTodoList(SortedMap<LocalDate,ArrayList<Task>>todoList){
		this.todoList=todoList;
	}
	
	public void setOverDueList(SortedMap<LocalDate, ArrayList<Task>>overdue){
		this.overdue=overdue;
	}
	
	public void setInputBoxText(String text){
		this.inputBoxText=text;
	}
	
	public void setExitState(boolean isExit){
		this.isExit=isExit;
	}
	
	public void setTitle(String title){
		this.title=title;
	}
	
	public ArrayList<Task>getFloatingList(){
		return floatingList;
	}
	
	public SortedMap<LocalDate,ArrayList<Task>>getTodoList(){
		return todoList;
	}
	
	public SortedMap<LocalDate, ArrayList<Task>>getOverdueList(){
		return overdue;
	}
	
	public String getInputBoxText(){
		return inputBoxText;
	}
	
	public String getTitle(){
		return title;
	}
	
	public boolean getExitState(){
		return isExit;
	}
	
}
```
###### src\common\Task.java
``` java
package common;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

/*
 * Add class description
 */
public class Task {

	private TaskType type;
	private String name;
	private LocalDate startDate;
	private LocalDate endDate;
	private LocalTime startTime;
	private LocalTime endTime;
	private boolean isDone;
	private boolean hasClash;
	private String[] displayName; 
	
	public Task(String name){
		this.name=name;
		this.displayName = formatName(this.name, 55);
		this.type=TaskType.FLOATING;
	}
	
	
	public Task(String name,LocalDate date,LocalTime time, TaskType type){
		this.name = name;
		this.displayName = formatName(this.name, 55);
		if(type==TaskType.TODO){
			this.startDate=date;
			this.startTime=time;
		}
		else if(type==TaskType.DEADLINE){
			this.endDate=date;
			this.endTime=time;
		}
		this.type=type;
	}
	
	public Task(String name,LocalDate startDate,LocalTime startTime,
			LocalDate endDate,LocalTime endTime){
		this.name=name;
		this.displayName=formatName(this.name, 55);
		this.startDate=startDate;
		this.startTime=startTime;
		this.endDate=endDate;
		this.endTime=endTime;
		this.type=TaskType.EVENT;
	}
	
	public void setName(String name){
		this.name=name;
	}
	
	public void setStartDate(LocalDate date) {
		this.startDate=date;
	}
	
	public void setStartTime(LocalTime time) {
		this.startTime=time;
	}
	
	public void setEndDate(LocalDate date) {
		this.endDate=date;
	}
	
	public void setEndTime(LocalTime time) {
		this.endTime=time;
	}
	
	public void setDoneStatus(boolean isDone) {
		this.isDone=isDone;
	}
	
	public void setClash(boolean hasClash) {
		this.hasClash=hasClash;
	}
	
	public void setDisplayName(String[] displayName) {
		this.displayName = displayName;
	}
	
	public String getName(){
		return name;
	}
	
	public LocalDate getStartDate(){
		return startDate;
	}
	
	public LocalTime getStartTime(){
		return startTime;
	}
	public String getStartTimeString(){
		if(startTime == null){
			return "";
		}
		return startTime.toString();
	}
	
	public LocalDate getEndDate(){
		return endDate;
	}
	
	public LocalTime getEndTime(){
		return endTime;
	}
	public String getEndTimeString(){
		if(endTime == null){
			return "";
		}
		return endTime.toString();
	}
	
	public LocalDate getDate(){
		if(startDate!=null){
			return startDate;
		}
		return endDate;
	}
	
	public LocalDate getDate(int startOrEnd){
		if(startOrEnd==0){
			return startDate;
		}
		else return endDate;
		
	}
	
	public LocalTime getTime(){
		if(startTime!=null){
			return startTime;
		}
		return endTime;
	}
		
	public TaskType getTaskType(){
		return type;
	}
	
	public boolean getDoneStatus(){
		return isDone;
	}
	
	public boolean getClash(){
		return hasClash;
	}
	
	public String[] getDisplayName(int length) {
		return formatName(this.name, length);
	}
	
	private String[] formatName(String taskName, int maxChars) {
		ArrayList<String> formattedName = new ArrayList<String>();
		String[] nameTokens = taskName.split(" ");
		String currentLine = "";
		for (int i = 0; i < nameTokens.length; i++) {
			String temp = currentLine + nameTokens[i];
			
			if (temp.length() <= maxChars-1) {
				currentLine = temp + " ";
			} else if (temp.length() == maxChars) {
				currentLine = temp;
			} else {
				if (currentLine.length() > 0) {
					formattedName.add(currentLine);
				}	
				if (nameTokens[i].length() < maxChars+1) {
					currentLine = nameTokens[i];
				} else {
					while (nameTokens[i].length() > maxChars) {
						formattedName.add(nameTokens[i].substring(0,maxChars-1) + "-");
						nameTokens[i] = nameTokens[i].substring(maxChars-1, nameTokens[i].length()-1);
					}
				}
				currentLine = nameTokens[i] + " ";
			}
		}
		formattedName.add(currentLine);
		return formattedName.toArray(new String[formattedName.size()]);
	}
	
	public String toString(){
		DateTimeFormatter dateformatter = DateTimeFormatter.ofPattern("d/M/yyyy");
		DateTimeFormatter timeformatter = DateTimeFormatter.ofPattern("h.mma");
		if(type==TaskType.FLOATING){
			return name;
		}
		else if(type==TaskType.DEADLINE){
			if(endTime!=null){
				return name+", by "+endTime.format(timeformatter)+", "+endDate.format(dateformatter);
			}
			return name+", by "+endDate.format(dateformatter);
		}
		else if(type==TaskType.TODO){
			if(startTime!=null){
				return name+", at "+startTime.format(timeformatter)+", "+startDate.format(dateformatter);
			}
			return name+", at "+startDate.format(dateformatter);
			
		}
		else{
			
			if (startTime == null && endTime == null) {
				return name + ", " + startDate.format(dateformatter) + " to " + endDate.format(dateformatter);
			} else if (startDate.isEqual(endDate)) {
				return name + ", " + startTime.format(timeformatter) + " to " + endTime.format(timeformatter)
					+ ", " + startDate.format(dateformatter);
			} else {
				return name + ", " + startTime.format(timeformatter) + " to " + endTime.format(timeformatter) 
					+ ", " + startDate.format(dateformatter) + " to " + endDate.format(dateformatter);
			}
		}
	}
	
	public boolean isEqual(Task other){		
		if(!this.getName().equals(other.getName()) || this.getTaskType() != other.getTaskType()){
			return false;
		}
		
		if(this.getTaskType() == TaskType.FLOATING){
			return true;
		} else if(this.getTaskType() == TaskType.DEADLINE){
			boolean sameDate = this.getEndDate().equals(other.getEndDate());
			if(this.getEndTime() != null){
				return sameDate && this.getEndTime().equals(other.getEndTime());
			} 
			return sameDate;	
		} else if(this.getTaskType() == TaskType.TODO){
			boolean sameDate = this.getStartDate().equals(other.getStartDate());
			if(this.getStartTime() != null){
				return sameDate && this.getStartTime().equals(other.getStartTime());
			}
			return sameDate;
		} else{
			boolean sameDate = this.getStartDate().equals(other.getStartDate()) && 
					this.getEndDate().equals(other.getEndDate());
			if(this.getStartTime() == null && other.getStartTime() == null){
				return sameDate;
			} else if(this.getStartTime() != null && other.getStartTime() != null){
				return sameDate && this.getStartTime().equals(other.getStartTime()) &&
						this.getEndTime().equals(other.getEndTime());
			} else{
				return false;
			}
		}
	}	
}
```
###### src\common\TaskType.java
``` java
package common;

public enum TaskType {
	FLOATING,EVENT,TODO,DEADLINE
}
```
###### src\logic\AddCommand.java
``` java
package logic;

import java.time.LocalDate;

import common.Display;
import common.Task;
/*
 * Add class description
 */
public class AddCommand implements Command{
	private TaskManager manager;
	private Task taskRef;
	
	public AddCommand(TaskManager manager){
		this.manager=manager;
	}
	
	public boolean execute(Task task){	
		if(task==null){
			return false;
		}
		
	    if(!manager.addTask(task)){
	    	Display.setFeedBack("You have already added this task.");
	    	return false;
	    }
	    
	    taskRef=task;
	    LocalDate date = taskRef.getDate();
	    String dateString = (date == null) ? "floating tasks" : date.toString();
	    String taskName = task.getName();
	    if (taskName.length() > 30){
	    	taskName = taskName.substring(0,30) + "...";
	    }
	    Display.setFeedBack("Task added: " + "[" + dateString + "] " + "\"" + taskName + "\"");
	    return true;
	}
	
	
	public void undo(){
		manager.deleteTask(taskRef);
	}
	
	public void redo(){
		manager.addTask(taskRef);
	}
	
}
```
###### src\logic\Command.java
``` java
package logic;

/*
 * add description
 */
public interface Command {
	public void undo();
	public void redo();
}
```
###### src\logic\CommandStack.java
``` java
package logic;
/*
 * add description/
 */
import java.util.LinkedList;

public class CommandStack {
	private LinkedList<Command> undoStack;
	private LinkedList<Command> redoStack;
	private int undoStackSize;
	private static final int maxStackSize=5;
	
	
	public CommandStack(){
		undoStackSize=0;
		undoStack=new LinkedList<Command>();
		redoStack=new LinkedList<Command>();
	}
	
	public void addCommand(Command command){
		if(undoStackSize<maxStackSize){
			undoStackSize++;
		}
		else{
			undoStack.pollLast();
		}
		undoStack.push(command);
		
		//if user enter a new command after undo, he is unable to revert back to the state before undo
		if(!redoStack.isEmpty()){
			redoStack.clear();
		}
	}
	
	public boolean undoOperation(){
		if(undoStack.peek()==null){
			return false;
		}
		undoStack.peek().undo();
		redoStack.push(undoStack.pop());
		undoStackSize--;
		return true;
	}
	
	public boolean redoOperation(){
		if(redoStack.peek()==null){
			return false;
		}
		redoStack.peek().redo();
		undoStack.push(redoStack.pop());
		undoStackSize++;
		return true;
	}
	
	// Returns the undo stack for testing purposes. Comment out when not in use.
	/*public LinkedList<Command> getUndoStack() {
		return undoStack;
	}*/
	
	// Returns the redo stack for testing purposes. Comment out when not in use.
	/*public LinkedList<Command> getRedoStack() {
		return redoStack;
	}*/
}



```
###### src\logic\Controller.java
``` java
package logic;

import common.Pair;
import common.ProgramState;
import common.Task;
import parser.CommandParser;
import storage.StorageControl;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import common.Auxiliary;
import common.Display;

public class Controller {
	private static Pair<Task,Task>taskPair = new Pair<Task,Task>(null,null);
	private static final Logger log = Logger.getLogger("controller");
	
	private TaskManager manager;
	private CommandStack commandStack;
	private CommandParser parser;
	private StorageControl storage;
	private ProgramState state;
	
	private static final String MESSAGE_CHANGE_VIEW = "Input 'view normal' to return to main calendar.";
	private static final String MESSAGE_INVALID_DATE_RANGE = "Invalid view range specified!";
	private static final String MESSAGE_EDIT = "Make changes to the task in text box, then press ENTER.";
	private static final String MESSAGE_UNRECOGNISED_COMMAND = "Unrecognized command. Press F2 for Help Screen.";
	private static final String MESSAGE_CLEAR = "All tasks have been cleared.";
	private static final String MESSAGE_INPUT_INSTRUCTION = "Input command into the field below.";
	
	private static final String MESSAGE_LOG_CREATE_TASK = "called parser to create a task.";
	private static final String MESSAGE_LOG_CREATE_DATE_INDEX_PAIR = "called parser to create date index pair.";
	private static final String MESSAGE_LOG_CREATE_DATE_PAIR = "called parser to create date pair.";
	private static final String MESSAGE_LOG_SAVE_TASKS = "called storage to save tasks.";
	
	public Controller(){
		storage = new StorageControl();
		manager = new TaskManager(storage);
		commandStack = new CommandStack();
		parser = new CommandParser();
		state = new ProgramState();
		initializeProgramState();
	}
	
	public void initializeProgramState(){
		state.setFLoatingList(manager.getFloating(false));
		state.setTodoList(manager.getTwoWeek());
		state.setOverDueList(manager.getDatedPrevious());
	}
	
	public ProgramState getProgramState(){
		return state;
	}
	
	public Task findTask(String string){
		
		ArrayList<Task> output = manager.searchTasks(parser.query(string));
		if(output == null){
			return null;
		}
		return output.get(0);
	}
	
	
	public void addCommand(String command){
		String commandString = Auxiliary.getFirstWord(command);
		String parameterString = Auxiliary.removeFirstWord(command);
		boolean canSave = true;
		state.setInputBoxText("");
		
		if(taskPair.getFirst() != null){
			Task task = parser.createTask(command);
			if(task!=null){
				taskPair.setSecond(parser.createTask(command));
				log.log(Level.INFO, MESSAGE_LOG_CREATE_TASK);
				EditCommand edit = new EditCommand(manager);
				if(edit.execute(taskPair)){
					commandStack.addCommand(edit);
				}
			}
			taskPair.setFirst(null);
			taskPair.setSecond(null);
		}
		
		else{
			switch(commandString.toLowerCase()){
				case "add":
					AddCommand add = new AddCommand(manager);
					if(add.execute(parser.createTask(parameterString))){
						commandStack.addCommand(add);
					}	
					log.log(Level.INFO, MESSAGE_LOG_CREATE_TASK);
					break;
				case "edit":
					ArrayList<Task>taskList = manager.searchTasks(parser.query(parameterString));
					if(taskList != null && taskList.get(0) != null){
						Task unmodified = taskList.get(0);
						taskPair.setFirst(unmodified);
						state.setInputBoxText(unmodified.toString());
						Display.setFeedBack(MESSAGE_EDIT);
					} else{
						state.setInputBoxText(command);
					}
					log.log(Level.INFO, MESSAGE_LOG_CREATE_DATE_INDEX_PAIR);
					break;
				case "done":
					DoneCommand done = new DoneCommand(manager);
					if(done.execute(parser.query(parameterString))){
						commandStack.addCommand(done);
					} else{
						state.setInputBoxText(command);
					}
					log.log(Level.INFO, MESSAGE_LOG_CREATE_DATE_INDEX_PAIR);
					break;
				case "del":
				case "delete":
					DeleteCommand delete = new DeleteCommand(manager);
					if(delete.execute(parser.query(parameterString))){
						commandStack.addCommand(delete);
					} else{
						state.setInputBoxText(command);
					}
					log.log(Level.INFO, MESSAGE_LOG_CREATE_DATE_INDEX_PAIR);
					break;	
				case "search":
					state.setFLoatingList(manager.getMatchedFloating(parameterString));
					state.setTodoList(manager.getMatchedDated(parameterString));
					state.setTitle("         â—? Searching: [" + parameterString + "] â—?");
					Display.setFeedBack(MESSAGE_CHANGE_VIEW);
					canSave = false;
					break;
				case "view":
					if(!changeDisplayMode(parameterString)){
						state.setInputBoxText(command);
					}
					canSave = false;
					break;
				case "save":
					storage.changeDirectory(parameterString);
					canSave = false;
					break;
				case "undo":
					commandStack.undoOperation();
					Display.setFeedBack("");
					break;
				case "redo":
					commandStack.redoOperation();
					Display.setFeedBack("");
					break;
				case "exit":
					state.setExitState(true);
					canSave = false;
					break;
				case "clear":
					manager.clearAllTasks();
					state.setFLoatingList(manager.getFloating(false));
					state.setTodoList(manager.getDated(false));
					Display.setFeedBack(MESSAGE_CLEAR);
					break;
				default:
					Display.setFeedBack(MESSAGE_UNRECOGNISED_COMMAND);
					state.setInputBoxText(command);
			}
		}
		
		
		if(canSave){
			saveToStorage();
		}
		
	}
	
	private void saveToStorage(){
		log.log(Level.INFO, MESSAGE_LOG_SAVE_TASKS);
		storage.save(manager.getTaskArray(true),true);
		storage.save(manager.getTaskArray(false),false);
	}
	
	private boolean changeDisplayMode(String mode){
		boolean canView = true;
		if(mode.equals("done")){
			state.setFLoatingList(manager.getFloating(true));
			state.setTodoList(manager.getDated(true));
			state.setTitle("              â—? Viewing: Done Tasks â—?");
			Display.setFeedBack(MESSAGE_CHANGE_VIEW);
		} else if(mode.equals("normal") || mode.equals("norm")){
			state.setFLoatingList(manager.getFloating(false));
			state.setTodoList(manager.getTwoWeek());
			state.setTitle("                         To-Do List");
			Display.setFeedBack(MESSAGE_INPUT_INSTRUCTION);
		} else if(mode.equals("all")){
			state.setFLoatingList(manager.getFloating(false));
			state.setTodoList(manager.getDated(false));
			state.setTitle("              â—? Viewing: All Tasks â—?");
			Display.setFeedBack(MESSAGE_CHANGE_VIEW);
		} else if(mode.equals("previous") || mode.equals("prev") || mode.equals("overdue")){
			state.setFLoatingList(null);
			state.setTodoList(manager.getDatedPrevious());
			state.setTitle("              â—? Viewing: Overdue Tasks â—?");
			Display.setFeedBack(MESSAGE_CHANGE_VIEW);
		} else if(parser.queryDateRange(mode) != null){
			Pair<LocalDate,LocalDate>datePair = parser.queryDateRange(mode);
			log.log(Level.FINE, MESSAGE_LOG_CREATE_DATE_PAIR);
			state.setFLoatingList(null);
			state.setTodoList(manager.getDateRange(datePair.getFirst(), datePair.getSecond()));
			String dateRange = datePair.getFirst().toString();
			if (datePair.getFirst().equals(datePair.getSecond())){
				dateRange = datePair.getFirst().toString();
				state.setTitle("     â—? Viewing: Tasks on " + dateRange + " â—?");
			} else {
				dateRange = "" + datePair.getFirst() + " - " +  datePair.getSecond();
				state.setTitle("â—? Viewing: " + dateRange + " â—?");
			
			}
			Display.setFeedBack(MESSAGE_CHANGE_VIEW);
		} else{
			Display.setFeedBack(MESSAGE_INVALID_DATE_RANGE);
			canView = false;
		}
		return canView;
	}
	
	/* 
	 * @return a Task representation of a string input.
	 * Called by GUI's colorizer.
	 * @param taskInformation is the task string without 'add' in front.
	 */
	public Task parseNewTask(String taskInformation){
		return parser.createTask(taskInformation);
	}
	
}
```
###### src\logic\DeleteCommand.java
``` java
package logic;

import java.time.LocalDate;
import java.util.ArrayList;

import common.Display;
import common.Pair;
import common.Task;
/*
 * Add class description
 */
public class DeleteCommand implements Command{
	private TaskManager manager;
	private Task taskRef;
	private ArrayList<Task> taskListRef;
	
	public DeleteCommand(TaskManager manager){
		this.manager=manager;
	}
	
	public boolean execute(Pair<LocalDate,ArrayList<Integer>>pair){
		
		ArrayList<Task>taskList=manager.searchTasks(pair);
		if(taskList==null){
			return false;
		}
		
		LocalDate date=taskList.get(0).getDate();
		String dateString = (date == null) ? "floating tasks" : date.toString();
		
		if(taskList.size()==1){
			taskRef=taskList.get(0);
			manager.deleteTask(taskRef);
			Display.setFeedBack("Task deleted: ["+dateString+"] "+"\"" + taskRef.getName() + "\"");
			return true;
		} else{
			taskListRef=taskList;
			manager.deleteMultipleTasks(taskListRef);
			Display.setFeedBack("Tasks deleted: ["+dateString+"] "+"\"" + taskListRef.get(0).getName() + "\""+"...");
			return true;
		}
		
	}
	
	public void undo(){
		if(taskRef!=null){
			manager.addTask(taskRef);
		} else{
			manager.addMultipleTasks(taskListRef);
		}
		
	}
	
	public void redo(){
		if(taskRef!=null){
			manager.deleteTask(taskRef);
		} else{
			manager.deleteMultipleTasks(taskListRef);
		}
	}
}
```
###### src\logic\DoneCommand.java
``` java
package logic;


import java.time.LocalDate;
import java.util.ArrayList;

import common.Display;
import common.Pair;
import common.Task;

public class DoneCommand implements Command{
	private TaskManager manager;
	private Task taskRef;
	private ArrayList<Task> taskListRef;
	
	public DoneCommand(TaskManager manager){
		this.manager=manager;
	}
	
	public boolean execute(Pair<LocalDate,ArrayList<Integer>>pair){
		ArrayList<Task>taskList=manager.searchTasks(pair);
		if(taskList==null){
			return false;
		}
		
		LocalDate date=taskList.get(0).getDate();
		String dateString = (date == null) ? "floating tasks" : date.toString();
		
		if(taskList.size()==1){
			taskRef=taskList.get(0);
			manager.deleteTask(taskRef);
			taskRef.setDoneStatus(true);
			manager.addTask(taskRef);
			Display.setFeedBack("Marked as done: [" + dateString + "] " + "\"" + taskRef.getName() + "\"");
			return true;
		}
		else{
			taskListRef=taskList;
			manager.deleteMultipleTasks(taskListRef);
			for(Task task:taskListRef){
				task.setDoneStatus(true);
			}
			manager.addMultipleTasks(taskListRef);
			Display.setFeedBack("Marked as done: [" + dateString + "] " + "\"" + taskListRef.get(0).getName() + "\""+"...");
			return true;
		}
		
	}
	
	public void undo(){
		if(taskRef!=null){
			manager.deleteTask(taskRef);
			taskRef.setDoneStatus(false);
			manager.addTask(taskRef);
		} else{
			manager.deleteMultipleTasks(taskListRef);
			for(Task task:taskListRef){
				task.setDoneStatus(false);
			}
			manager.addMultipleTasks(taskListRef);
			
		}
		
	}
	
	public void redo(){
		if(taskRef!=null){
			manager.deleteTask(taskRef);
			taskRef.setDoneStatus(true);
			manager.addTask(taskRef);
		} else{
			manager.deleteMultipleTasks(taskListRef);
			for(Task task:taskListRef){
				task.setDoneStatus(true);
			}
			manager.addMultipleTasks(taskListRef);
		}
		
	}
}
```
###### src\logic\EditCommand.java
``` java
package logic;


import common.Display;
import common.Pair;
import common.Task;

public class EditCommand implements Command{
	private TaskManager manager;
	private Task unmodified;
	private Task modified;
	
	public EditCommand(TaskManager manager){
		this.manager=manager;
	}
	
	public boolean execute(Pair<Task,Task>pair){
		unmodified=pair.getFirst();
		modified=pair.getSecond();
		manager.deleteTask(unmodified);
		manager.addTask(modified);
		Display.setFeedBack("Task modified: "+"\""+unmodified.getName()+"\"");
		return true;
	}
	
	
	public void undo(){
		manager.deleteTask(modified);
		manager.addTask(unmodified);
	}
	
	public void redo(){
		manager.deleteTask(unmodified);
		manager.addTask(modified);
	}
}
```
###### src\logic\TaskManager.java
``` java
package logic;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import common.Display;
import common.Pair;
import common.Task;
import common.TaskType;
import storage.StorageControl;

public class TaskManager {
	private static LocalDate THE_MYTH_DAY = LocalDate.of(1979, 7, 11);
	private static final Logger log = Logger.getLogger("TaskManager");
	
	private SortedMap<LocalDate,ArrayList<Task>>doneList;
	private SortedMap<LocalDate,ArrayList<Task>>todoList;
	

	private static final String MESSAGE_RETRIEVE_TASK = "called storage to retrieve task list";
	private static final String MESSAGE_TASK_DO_NOT_EXIST = "Error : Task or tasks do not exist.";
	private static final String MESSAGE_DATE_DO_NOT_EXIST = "Error : You do not have any task on this date.";
	
	private static final String MESSAGE_ASSERTION_NULL_INPUT = "Null input detected";
	
	public TaskManager(StorageControl storage){
		doneList = new TreeMap<LocalDate,ArrayList<Task>>();
		doneList.put(THE_MYTH_DAY, new ArrayList<Task>());
		todoList = new TreeMap<LocalDate,ArrayList<Task>>();
		todoList.put(THE_MYTH_DAY, new ArrayList<Task>());
		
		
		storage.setEnvironment();
		addMultipleTasks(storage.load(true));
		addMultipleTasks(storage.load(false));
		log.log(Level.INFO, MESSAGE_RETRIEVE_TASK);
	}
	
// --------------------------------------Getters------------------------------------------
	
	public ArrayList<Task> getTaskArray(boolean isDone){
		SortedMap<LocalDate,ArrayList<Task>>taskList = isDone?doneList:todoList;
		Set<Task>taskSet = new HashSet<Task>();
		for(LocalDate date:taskList.keySet()){
			for(Task task:taskList.get(date)){
				taskSet.add(task);
			}
		}
		return new ArrayList<Task>(taskSet);
	} 
	
	public ArrayList<Task> getFloating(boolean isDone){
		return isDone?doneList.get(THE_MYTH_DAY):todoList.get(THE_MYTH_DAY);
	}
	
	public SortedMap<LocalDate, ArrayList<Task>> getDated(boolean isDone){
		return isDone?doneList.tailMap(THE_MYTH_DAY.plusDays(1)):todoList.tailMap(THE_MYTH_DAY.plusDays(1));
	}
	
	// Returns a SortedMap of Task objects with date between current date and two weeks from current date
	public SortedMap<LocalDate, ArrayList<Task>> getTwoWeek(){
		return todoList.subMap(LocalDate.now(), LocalDate.now().plusWeeks(2));
	}
	
	// Returns a SortedMap of Task objects with date before the current date
	public SortedMap<LocalDate, ArrayList<Task>> getDatedPrevious(){
		return todoList.subMap(THE_MYTH_DAY.plusDays(1), LocalDate.now());
	}
	
	// Returns a SortedMap of Task objects with date between the two input dates
	public SortedMap<LocalDate,ArrayList<Task>> getDateRange(LocalDate date1,LocalDate date2){	
		return todoList.subMap(date1, date2.plusDays(1));
	}
	
	// Returns a SortedMap of dated Task objects with name that contains the input string
	public SortedMap<LocalDate,ArrayList<Task>> getMatchedDated(String keyword){
		SortedMap<LocalDate,ArrayList<Task>>matchedList = new TreeMap<LocalDate,ArrayList<Task>>();
		for(LocalDate date:todoList.keySet()){
			if(date.isEqual(THE_MYTH_DAY)){
				continue;
			}
			
			for(Task task:todoList.get(date)){
				if(task.getName().contains(keyword)){
					addTaskAtDate(matchedList,task.getDate(),task);
				}
			}
		}
		return matchedList;
	}
	
	// Returns an ArrayList of undated Task objects with name that contains the input string
	public ArrayList<Task>getMatchedFloating(String keyword){
		ArrayList<Task>matchedFloating=new ArrayList<Task>();
		for(Task task:todoList.get(THE_MYTH_DAY)){
			if(task.getName().contains(keyword)){
				matchedFloating.add(task);
			}
		}
		return matchedFloating;
	}
	
	
//-------------------------------Task List Modifiers ---------------------------------------
	/**
	 * Return true if a Task object is successfully added to todoList
	 * Task object cannot be null
	 * 
	 * @param task	a Task object
	 * @return	a boolean value
	 */
		
	public boolean addTask(Task task){
		assert task != null : MESSAGE_ASSERTION_NULL_INPUT;
		boolean isDone = task.getDoneStatus();
		SortedMap<LocalDate,ArrayList<Task>>taskList = isDone?doneList:todoList;
		
		if(task.getTaskType() == TaskType.FLOATING){
			if(!addTaskAtDate(taskList,THE_MYTH_DAY,task)){
				return false;
			}
			sortTaskAtDate(taskList,THE_MYTH_DAY);
			return true;
		} else{
			if(task.getTaskType() == TaskType.EVENT && 
					task.getStartDate().isBefore(task.getEndDate())){
				
				LocalDate currentDate = task.getStartDate();
				while(!currentDate.isAfter(task.getEndDate())){
					
					if(!addTaskAtDate(taskList,currentDate,task)){
						return false;
					}
					sortTaskAtDate(taskList,currentDate);
					currentDate = currentDate.plusDays(1);
				}
				return true;
				
			} else{
				LocalDate date = task.getDate();
				if(!addTaskAtDate(taskList,date,task)){
					return false;
				}
				sortTaskAtDate(taskList,task.getDate());
				updateClashStatus(taskList.get(date));
				return true;
			}
			
			
		}
	}
	
	public void addMultipleTasks(ArrayList<Task>taskList){
		assert taskList != null : MESSAGE_ASSERTION_NULL_INPUT;
		for(Task task:taskList){
			addTask(task);
		}
	}
	
	
	/**
	 * Delete a Task object from todoList
	 * Task object cannot be null
	 * 
	 * @param task	a Task object
	 */
	public void deleteTask(Task task){
		assert task != null : MESSAGE_ASSERTION_NULL_INPUT;
		boolean isDone=task.getDoneStatus();
		SortedMap<LocalDate,ArrayList<Task>>taskList = isDone?doneList:todoList;
		
		if(task.getTaskType() == TaskType.FLOATING){
			removeTaskAtDate(taskList,THE_MYTH_DAY,task);
		}
		
		else{
			if(task.getTaskType() == TaskType.EVENT && 
					task.getStartDate().isBefore(task.getEndDate())){
				
				LocalDate currentDate = task.getStartDate();
				while(!currentDate.isAfter(task.getEndDate())){
					removeTaskAtDate(taskList,currentDate,task);
					currentDate = currentDate.plusDays(1);
				}
			}
			else{
				LocalDate date = task.getDate();
				removeTaskAtDate(taskList,date,task);
				if(taskList.containsKey(date)){
					updateClashStatus(taskList.get(date));
				}
			}
		}
		
	}
	
	public void deleteMultipleTasks(ArrayList<Task>taskList){
		assert taskList != null : MESSAGE_ASSERTION_NULL_INPUT;
		for(Task task:taskList){
			deleteTask(task);
		}
	}
	
	public void clearAllTasks(){
		doneList = new TreeMap<LocalDate,ArrayList<Task>>();
		doneList.put(THE_MYTH_DAY, new ArrayList<Task>());
		todoList = new TreeMap<LocalDate,ArrayList<Task>>();
		todoList.put(THE_MYTH_DAY, new ArrayList<Task>());
	}
	
	
// ------------------------------------- Task Query -----------------------------------------
	
	
	/**
	 * Return an ArrayList of Task objects from todoList
	 * null is returned when the ArrayList is empty
	 * 
	 * @param pair	a holder containing a LocalDate object and an ArrayList of Integer
	 * @return	an ArrayList of Task objects
	 */
	
	public ArrayList<Task> searchTasks(Pair<LocalDate,ArrayList<Integer>>pair){
		if(pair == null){
			return null;
		}
		
		ArrayList<Task>output;
		LocalDate date = pair.getFirst();
		ArrayList<Integer>indexList=pair.getSecond();
		if(indexList != null){
			output = searchMultipleTasksAtDate(date,indexList);
		}
		else{
			output = searchAllTasksAtDate(date);
		}
		return output;
	}
	
	protected ArrayList<Task>searchMultipleTasksAtDate(LocalDate date,ArrayList<Integer>indexList){
		ArrayList<Task>taskList = new ArrayList<Task>();
		for(int index:indexList){
			Task task = searchSingleTask(date,index);
			if(task != null){
				taskList.add(task);
			}
		}
		if(taskList.size() == 0){
			Display.setFeedBack(MESSAGE_TASK_DO_NOT_EXIST);
			return null;
		}
		return taskList;
	}
	
	protected Task searchSingleTask(LocalDate date,int displayIndex){
		int actualIndex=displayIndex-1;
		if(date == null){
			if(actualIndex >= todoList.get(THE_MYTH_DAY).size()){
				return null;
			}
			return todoList.get(THE_MYTH_DAY).get(actualIndex);
		}
		else{
			if(!todoList.containsKey(date) || actualIndex >= todoList.get(date).size()){
				return null;
			}
			return todoList.get(date).get(actualIndex);
		}
				
	}
	
	protected ArrayList<Task>searchAllTasksAtDate(LocalDate date){
		if(date == null){
			return new ArrayList<Task>(todoList.get(THE_MYTH_DAY));
		}
		else if(!todoList.containsKey(date)){
			Display.setFeedBack(MESSAGE_DATE_DO_NOT_EXIST);
			return null;
		}
		else{
			return new ArrayList<Task>(todoList.get(date));
		}
	}
	
//------------------------------------Auxiliary Methods---------------------------------------
	
	protected static void sortTaskAtDate(SortedMap<LocalDate,ArrayList<Task>>taskList,
			LocalDate date){
		assert (taskList != null && date != null) : MESSAGE_ASSERTION_NULL_INPUT;
		ArrayList<Task>tasks = taskList.get(date);
		
		//sort by time or name
		Collections.sort(tasks,new Comparator<Task>(){
			public int compare(Task t1,Task t2){
				if(t1.getTime() != null && t2.getTime() != null){
					return t1.getTime().compareTo(t2.getTime());
				}
				else if(t1.getTime() == null && t2.getTime() != null){
					return 1;
				}
				else if(t1.getTime() != null && t2.getTime() == null){
					return -1;
				}
				else{
					return t1.getName().compareTo(t2.getName());
				}
			}
		});
		
		//sort by task type
		Collections.sort(tasks,(Task t1,Task t2)->t1.getTaskType().compareTo(t2.getTaskType()));
	}
	
	
	protected static boolean addTaskAtDate(SortedMap<LocalDate,ArrayList<Task>>map,
			LocalDate date,Task input){
		assert (map != null && date != null && input != null) : MESSAGE_ASSERTION_NULL_INPUT;
		
		if(!map.containsKey(date)){
			map.put(date, new ArrayList<Task>());
		}
		for(Task task:map.get(date)){
			if(input.isEqual(task)){
				return false;
			}
		}
		
		map.get(date).add(input);
		return true;
	}
	
	protected static void removeTaskAtDate(SortedMap<LocalDate,ArrayList<Task>>map,
			LocalDate date,Task task){
		assert (map != null && date != null && task != null) : MESSAGE_ASSERTION_NULL_INPUT;
		
		map.get(date).remove(task);
		if(map.get(date).isEmpty() && !date.isEqual(THE_MYTH_DAY)){
			map.remove(date);
		}
	}
	
	//Update if timing of one event task clashes with that of another event task
	protected static void updateClashStatus(ArrayList<Task>taskList){
		assert taskList != null : MESSAGE_ASSERTION_NULL_INPUT;
		
		boolean isDone = taskList.get(0).getDoneStatus();
		ArrayList<Task>eventList = new ArrayList<Task>();
		for(Task task:taskList){
			if(task.getTaskType() == TaskType.EVENT && task.getTime() != null){
				task.setClash(false);
				eventList.add(task);
			}
		}
		
		if(isDone){
			return;
		}
		
		Task first,second;
		for(int i = 0;i < eventList.size()-1;i++){
			first=eventList.get(i);
			for(int j = i+1;j < eventList.size();j++){
				second = eventList.get(j);
				if(second.getStartTime().isBefore(first.getEndTime()) &&
						second.getEndTime().isAfter(first.getStartTime())){
					first.setClash(true);
					second.setClash(true);
				}
			}		
		}
	}
	
	
	
}
```
###### src\tests\ControllerTest.java
``` java

package tests;
import logic.Controller;

import static org.junit.Assert.*;

import java.time.LocalDate;

import org.junit.Before;
import org.junit.Test;

import common.Display;
import common.ProgramState;

public class ControllerTest {
	Controller controller = new Controller();
	ProgramState state = controller.getProgramState();
	LocalDate date = LocalDate.of(2015, 11, 7);
	
	@Before
	public void setUp() {
		controller.addCommand("clear");
		controller.addCommand("add do homework, 2 to 5pm, 7 nov");
		controller.addCommand("add feed the dog,6pm,7 nov");
		controller.addCommand("add floating task");
	}
	
	@Test
	public void addTaskPositive(){

		controller.addCommand("add revise for exam, 7 to 8pm, 7 nov");
		String name = state.getTodoList().get(date).get(1).getName();
		assertEquals(name,"revise for exam");
		assertEquals(state.getTodoList().get(date).size(),3);
		String feedbackString = "Task added: " + "[" + "2015-11-07" + "] " + "\"" + "revise for exam" + "\"";
		assertEquals(Display.showFeedBack(),feedbackString);
	}
	
	@Test
	public void addTaskNegative(){
		controller.addCommand("add do homework, 2 to 5pm, 7 nov");
		assertEquals(state.getTodoList().get(date).size(),2);
		assertEquals(Display.showFeedBack(),"You have already added this task.");
	}
	
	@Test
	public void deleteTaskPositive(){
		controller.addCommand("del 7 nov,1");
		assertEquals(state.getTodoList().get(date).size(),1);
		String name = state.getTodoList().get(date).get(0).getName();
		assertEquals(name,"feed the dog");
		assertEquals(Display.showFeedBack(),"Task deleted: ["+"2015-11-07"+"] "+"\"" + "do homework" + "\"");
	}
	
	@Test
	public void deleteTaskNegative(){
		controller.addCommand("del 7 nov,3");
		assertEquals(state.getTodoList().get(date).size(),2);
		String feedbackString = "Error : Task or tasks do not exist.";
		assertEquals(Display.showFeedBack(),feedbackString);
	}
	
	@Test
	public void deleteMultipleTaskPositive(){
		controller.addCommand("del 7 nov,1 2");
		assertEquals(state.getTodoList().containsKey(date),false);
		assertEquals(Display.showFeedBack(),"Tasks deleted: [2015-11-07] " +"\"" + "do homework" + "\"...");
	}
	
	@Test
	public void deleteMultipleTaskNegative(){
		controller.addCommand("del 7 nov,4 5");
		assertEquals(state.getTodoList().containsKey(date),true);
		assertEquals(state.getTodoList().get(date).size(),2);
		assertEquals(Display.showFeedBack(),"Error : Task or tasks do not exist.");
	}
	
	@Test
	public void editTaskPositive(){
		controller.addCommand("edit 7 nov,1");
		assertEquals(state.getInputBoxText(),"do homework, 2.00PM to 5.00PM, 7/11/2015");
		assertEquals(Display.showFeedBack(),"Make changes to the task in text box, then press ENTER.");
	}
	
	@Test
	public void editTaskNegative(){
		controller.addCommand("edit 7 nov,3");
		assertEquals(state.getInputBoxText(),"edit 7 nov,3");
		assertEquals(Display.showFeedBack(),"Error : Task or tasks do not exist.");
	}
	
	@Test
	public void taskEditedPostive(){
		controller.addCommand("edit 7 nov,2");
		String editedString = "feed the cat,6.00PM,7/11/15";
		controller.addCommand(editedString);
		assertEquals(state.getTodoList().get(date).get(1).getName(),"feed the cat");
		assertEquals(Display.showFeedBack(),"Task modified: "+"\""+"feed the dog"+"\"");
	}
	
	@Test
	public void taskEditedNegative(){
		controller.addCommand("edit 7 nov,2");
		String editedString = "       ";
		controller.addCommand(editedString);
		assertEquals(state.getTodoList().get(date).get(1).getName(),"feed the dog");
		assertEquals(Display.showFeedBack(),"You have not entered any task details.");
	}
	
	@Test
	public void doneTaskPositive(){
		controller.addCommand("done 7 nov,1");
		assertEquals(state.getTodoList().get(date).size(),1);
		String feedbackString = "Marked as done: [" + "2015-11-07" + "] " + "\"" + "do homework" + "\"";
		assertEquals(Display.showFeedBack(),feedbackString);
		
		controller.addCommand("view done");
		assertEquals(state.getTodoList().get(date).get(0).getName(),"do homework");
	}
	
	@Test
	public void doneTaskNegative(){
		controller.addCommand("done 7 nov,3");
		assertEquals(state.getInputBoxText(),"done 7 nov,3");
		assertEquals(Display.showFeedBack(),"Error : Task or tasks do not exist.");
	}
	
	@Test
	public void searchByKeyword(){
		controller.addCommand("search homework");
		assertEquals(state.getTodoList().get(date).get(0).getName(),"do homework");
	}
	
	@Test
	public void redoUndo(){
		controller.addCommand("undo");
		controller.addCommand("undo");
		controller.addCommand("undo");
		assertEquals(state.getTodoList().containsKey(date),false);
		controller.addCommand("redo");
		assertEquals(state.getTodoList().get(date).get(0).getName(),"do homework");
		controller.addCommand("redo");
		assertEquals(state.getTodoList().get(date).get(1).getName(),"feed the dog");
	}
	
	@Test
	public void randomWord(){
		controller.addCommand("what is a quantum computer");
		assertEquals(state.getInputBoxText(),"what is a quantum computer");
		assertEquals(Display.showFeedBack(),"Unrecognized command. Press F2 for Help Screen.");
	}
	
	@Test
	public void viewDateRangePositive(){
		controller.addCommand("view 7 nov");
		assertEquals(state.getTodoList().get(date).get(0).getName(),"do homework");
		assertEquals(state.getFloatingList(),null);
	}
	
	@Test
	public void viewDateRangeNegative(){
		controller.addCommand("view 7-5 nov 2015");
		assertEquals(state.getInputBoxText(),"view 7-5 nov 2015");
		assertEquals(Display.showFeedBack(),"Invalid view range specified!");
	}
	
```
###### src\tests\TaskManagerTest.java
``` java

package tests;
import logic.TaskManager;
import storage.StorageControl;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.SortedMap;

import org.junit.Before;
import org.junit.Test;

import common.Display;
import common.Pair;
import common.Task;
import common.TaskType;

public class TaskManagerTest {
	private StorageControl storage = new StorageControl();
	private TaskManager manager = new TaskManager(storage);
	LocalDate date = LocalDate.of(2015, 11, 13);
	
	@Before
	public void setUp() {
		manager.clearAllTasks();
		
		//initializing all tasks
		
		Task dated_1 = new Task("write Junit test cases", date,null,TaskType.TODO);
		Task dated_2 = new Task("submit report", date,LocalTime.of(19, 30),TaskType.DEADLINE);
		Task dated_3 = new Task("software demo", date,LocalTime.of(17, 0),date,LocalTime.of(18, 0));
		manager.addTask(dated_1);
		manager.addTask(dated_2);
		manager.addTask(dated_3);
	}
	
	@Test
	public void addTaskIsSorted(){
		Task task1 = new Task("submit developer guide",date,LocalTime.of(18, 30),TaskType.DEADLINE);
		Task task2 = new Task("apply for scholarship",date,null,TaskType.TODO);
		manager.addTask(task1);
		manager.addTask(task2);
		SortedMap<LocalDate,ArrayList<Task>>todoList = manager.getDated(false);
		
		assertEquals(todoList.get(date).size(),5);
		
		assertEquals(todoList.get(date).get(3).getName(),"submit developer guide");
		assertEquals(todoList.get(date).get(4).getName(),"submit report");
		
		assertEquals(todoList.get(date).get(1).getName(),"apply for scholarship");
		assertEquals(todoList.get(date).get(2).getName(),"write Junit test cases");
		
		assertEquals(todoList.get(date).get(0).getName(),"software demo");
		assertEquals(todoList.get(date).get(1).getName(),"apply for scholarship");
		
		assertEquals(todoList.get(date).get(2).getName(),"write Junit test cases");
		assertEquals(todoList.get(date).get(3).getName(),"submit developer guide");
	}
	
	@Test
	public void addTaskCheckDuplicateNegative(){
		Task task = new Task("watch star war movie",LocalDate.of(2015, 12, 15),null,TaskType.TODO);
		assertEquals(manager.addTask(task),true);
	}
	
	@Test
	public void addTaskCheckDuplicatePositive(){
		Task task = new Task("submit report", date,LocalTime.of(19, 30),TaskType.DEADLINE);
		assertEquals(manager.addTask(task),false);
	}
	
	@Test
	public void addTaskCheckClashPositive(){
		Task task = new Task("another event", date,LocalTime.of(16, 0),date,LocalTime.of(17, 20));
		manager.addTask(task);
		assertEquals(task.getClash(),true);
		assertEquals(manager.getDated(false).get(date).get(0).getClash(),true);
	}
	
	@Test
	public void addTaskCheckClashNegative(){
		Task task = new Task("another event", date,LocalTime.of(16, 0),date,LocalTime.of(17, 0));
		manager.addTask(task);
		assertEquals(task.getClash(),false);
		assertEquals(manager.getDated(false).get(date).get(0).getClash(),false);
	}
	
	@Test
	public void searchTasksPositive(){
		ArrayList<Integer> list1 = new ArrayList<Integer>(Arrays.asList(1));
		ArrayList<Integer> list2 = new ArrayList<Integer>(Arrays.asList(1,2,3));
		ArrayList<Integer> list3 = new ArrayList<Integer>(Arrays.asList(1,2,5));
		Pair<LocalDate,ArrayList<Integer>> pair1 = new Pair<LocalDate,ArrayList<Integer>>(date,list1);
		Pair<LocalDate,ArrayList<Integer>> pair2 = new Pair<LocalDate,ArrayList<Integer>>(date,list2);
		Pair<LocalDate,ArrayList<Integer>> pair3 = new Pair<LocalDate,ArrayList<Integer>>(date,list3);
		
		
		ArrayList<Task> output1 = manager.searchTasks(pair1);
		assertEquals(output1.get(0).getName(),"software demo");
		
		ArrayList<Task> output2 = manager.searchTasks(pair2);
		assertEquals(output2.get(1).getName(),"write Junit test cases");
		assertEquals(output2.get(2).getName(),"submit report");
		
		ArrayList<Task> output3 = manager.searchTasks(pair3);
		assertEquals(output3.size(),2);

	}
	
	@Test
	public void searchTasksNegative(){
		ArrayList<Integer> list1 = new ArrayList<Integer>(Arrays.asList(5));
		Pair<LocalDate,ArrayList<Integer>> pair1 = new Pair<LocalDate,ArrayList<Integer>>(date,list1);
		
		ArrayList<Task> output1 = manager.searchTasks(pair1);
		assertEquals(output1,null);
		assertEquals(Display.showFeedBack(),"Error : Task or tasks do not exist.");
	}
	
	@Test
	public void searchAllTasksAtDatePositive(){
		Pair<LocalDate,ArrayList<Integer>> pair1 = new Pair<LocalDate,ArrayList<Integer>>(date,null);
		
		ArrayList<Task> output1 = manager.searchTasks(pair1);
		assertEquals(output1.size(),3);
		
	}
	
	@Test
	public void searchAllTasksAtDateNegative(){
		LocalDate date1 = LocalDate.of(2015,1,12);
		Pair<LocalDate,ArrayList<Integer>> pair1 = new Pair<LocalDate,ArrayList<Integer>>(date1,null);
		
		ArrayList<Task> output1 = manager.searchTasks(pair1);
		assertEquals(output1,null);
		assertEquals(Display.showFeedBack(),"Error : You do not have any task on this date.");
	}
	
	
	@Test
	public void deleteTaskTaskDeleted(){
		Task task = manager.searchTasks(new Pair<LocalDate,ArrayList<Integer>>(date,
				new ArrayList<Integer>(Arrays.asList(2)))).get(0);
		manager.deleteTask(task);
		assertEquals(manager.getDated(false).get(date).get(1).getName(),"submit report");
		assertEquals(manager.getDated(false).get(date).size(),2);
	}
	
	@Test
	public void deleteTaskKeyDeleted(){
		LocalDate date1 = LocalDate.of(2015, 11, 10);
		Task task = new Task("random event",date1,null,date1,null);
		manager.addTask(task);
		assertEquals(manager.getDated(false).containsKey(date1),true);
		manager.deleteTask(task);
		assertEquals(manager.getDated(false).containsKey(date1),false);
	}

}
```

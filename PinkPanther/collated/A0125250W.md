# A0125250W
###### src\storage\StorageControl.java
``` java

package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.*;

import com.google.gson.Gson;

import common.Display;
import common.Task;


public class StorageControl {
	// Attributes
	private static File latestDirectoryTextFile = new File("Latest directory.txt");
	private File directory;
	private TaskStorage taskFile;
	private Gson gson = new Gson();
	private static Logger logger = Logger.getLogger("StorageControl");

	// Feedback Messages
	private static final String MESSAGE_FEEDBACK_SUCCESSFUL_DIRECTORY_CHANGE = "Directory changed to: \"%1$s\"";
	private static final String MESSAGE_FEEDBACK_SECURITY_EXCEPTION = "Security manager exists and denies write access to: \"%1$s\"";
	private static final String MESSAGE_FEEDBACK_NO_INPUT_DIRECTORY = "No directory path was entered";
	private static final String MESSAGE_FEEDBACK_IS_NOT_DIRECTORY = "\"%1$s\" is not a directory";
	private static final String MESSAGE_FEEDBACK_SAVE_UNSUCCESSFUL = "Save unsuccessful";
	private static final String MESSAGE_FEEDBACK_SAME_DIRECTORY = "\"%1$s\" is the current directory, directory remains unchanged";
	
	// Logging Messages
	private static final String MESSAGE_LOG_WROTE_LATEST_DIRECTORY = "Wrote latest directory from \"Latest Directory.txt\"";
	private static final String MESSAGE_LOG_WRITING_LATEST_DIRECTORY = "Writing latest directory to \"Latest Directory.txt\"";
	private static final String MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION = "Input ouput exception encountered";
	private static final String MESSAGE_LOG_FILE_NOT_FOUND_EXCEPTION = "File not found exception encountered";
	private static final String MESSAGE_LOG_READ_LATEST_DIRECTORY = "Read latest directory from \"Latest Directory.txt\"";
	private static final String MESSAGE_LOG_READING_LATEST_DIRECTORY = "Reading latest directory from \"Latest Directory.txt\"";
	private static final String MESSAGE_LOG_LOADING_TEXTFILES = "Loading textfiles";
	private static final String MESSAGE_LOG_UNSUCCESSFULLY_SAVED_TEXTFILES = "Textfile unsuccessfully saved";
	private static final String MESSAGE_LOG_SUCCESSFULLY_SAVED_TEXTFILES = "Textfile successfully saved";
	private static final String MESSAGE_LOG_SAVING_TEXTFILES = "Saving textfiles";
	private static final String MESSAGE_LOG_NULL_POINTER_EXCEPTION = "Null pointer exception encountered";
	private static final String MESSAGE_LOG_SECURITY_EXCEPTION = "Security exception encountered";
	private static final String MESSAGE_LOG_END_CHANGE_DIRECTORY = "End of directory change";
	private static final String MESSAGE_LOG_REPLACED_CURRENT_DIRECTORY = "Current directory replaced";
	private static final String MESSAGE_LOG_REPLACING_CURRENT_DIRECTORY = "Replacing current directory";
	private static final String MESSAGE_LOG_TEXTFILES_MOVED_FROM_PREVIOUS = "Textfiles from previous directory moved";
	private static final String MESSAGE_LOG_MOVING_TEXTFILES_FROM_PREVIOUS = "Moving textfiles from previous directory";
	private static final String MESSAGE_LOG_INVALID_TARGET_DIRECTORY = "Invalid target directory";
	private static final String MESSAGE_LOG_DIRECTORY_EXISTS_CREATING_ALTERNATIVE = "Target directory already exists, creating alternative filepath";
	private static final String MESSAGE_LOG_TARGET_DIRECTORY_SAME_CURRENT_DIRECTORY = "Target directory is the same as the current directory";
	private static final String MESSAGE_LOG_START_CHANGE_DIRECTORY = "Start of directory change";
	private static final String MESSAGE_LOG_END_SET_ENVIRONMENT = "TaskStorage instantiated, end of set environment";
	private static final String MESSAGE_LOG_LATEST_DIRECTORY_SET = "Set the latest directory";
	private static final String MESSAGE_LOG_DEFAULT_DIRECTORY_CREATED = "Default directory C:\\PPCalendar created";
	private static final String MESSAGE_LOG_NO_OR_INVALID_LATEST_DIRECTORY = "No latest directory OR invalid latest directory obtained";
	private static final String MESSAGE_LOG_START_SET_ENVIRONMENT = "Obtained the latest directory, start of set environment";
	
	// Assertion Messages
	private static final String MESSAGE_ASSERTION_NULL_PARAMETER = "Logic error. Null input passed in as parameter!";
	
	public StorageControl() {
	}
	
	/**
	 * Sets and returns the filepath of the directory in which the files are to be saved in.
	 * A default filepath is set and returned if no directory is specified in "Latest Directory.txt".
	 * 
	 * @param Void.
	 * @return	String of the current directory's filepath
	 */
	public String setEnvironment() {
		directory = getLatestDirectory();
		logger.log(Level.FINE, MESSAGE_LOG_START_SET_ENVIRONMENT);
		
		if (directory == null || directory.isDirectory() == false) {
			logger.log(Level.WARNING, MESSAGE_LOG_NO_OR_INVALID_LATEST_DIRECTORY);
			int numOfExistingFiles = 1;
			directory = new File("C:\\PPCalendar");
			logger.log(Level.INFO, MESSAGE_LOG_DEFAULT_DIRECTORY_CREATED);
			while (directory.mkdir() == false) {
				directory = new File("C:\\PPCalendar" + " (" + numOfExistingFiles + ")");
				numOfExistingFiles++;
			}
			this.setLatestDirectory();
			logger.log(Level.FINE, MESSAGE_LOG_LATEST_DIRECTORY_SET);
		}
		taskFile = new TaskStorage(directory);
		logger.log(Level.FINE, MESSAGE_LOG_END_SET_ENVIRONMENT);
		return directory.getPath();
	}
	
	/**
	 * Returns a boolean value depending on the success of the save directory change.
	 * This method changes the directory in which the task list textfiles are to be saved.
	 * All the textfiles from the previous directory are moved to the new directory if successful.
	 * 
	 * @param String of the new directory's filepath.
	 * @return Boolean variable indicating the success of the save directory change.
	 */
	public boolean changeDirectory(String input_NewDirectory) {
		assert input_NewDirectory != null : MESSAGE_ASSERTION_NULL_PARAMETER;
		File newDirectory = new File(input_NewDirectory);
		int numOfExistingFiles = 1;
		logger.log(Level.FINE, MESSAGE_LOG_START_CHANGE_DIRECTORY);
		
		try {
			if (newDirectory.equals(getLatestDirectory()) == true) {
				logger.log(Level.WARNING, MESSAGE_LOG_TARGET_DIRECTORY_SAME_CURRENT_DIRECTORY);
				Display.setFeedBack(String.format(MESSAGE_FEEDBACK_SAME_DIRECTORY, directory.getPath()));
				return false;
			}
			else if (newDirectory.isDirectory() == true) {
				logger.log(Level.WARNING, MESSAGE_LOG_DIRECTORY_EXISTS_CREATING_ALTERNATIVE);
				while (newDirectory.isDirectory() == true) {
					newDirectory = new File(input_NewDirectory + " (" + numOfExistingFiles + ")");
					numOfExistingFiles++;
				}
				newDirectory.mkdir();
			}
			else if (input_NewDirectory.substring(1, 3).equals(":\\") == false || newDirectory.mkdir() == false) {
				logger.log(Level.WARNING, MESSAGE_LOG_INVALID_TARGET_DIRECTORY);
				Display.setFeedBack(String.format(MESSAGE_FEEDBACK_IS_NOT_DIRECTORY, input_NewDirectory));
				return false;
			}
			
			logger.log(Level.FINE, MESSAGE_LOG_MOVING_TEXTFILES_FROM_PREVIOUS);
			taskFile.moveFiles(newDirectory);
			logger.log(Level.FINE, MESSAGE_LOG_TEXTFILES_MOVED_FROM_PREVIOUS);
			
			logger.log(Level.FINE, MESSAGE_LOG_REPLACING_CURRENT_DIRECTORY);
			directory.delete();
			directory = newDirectory;
			logger.log(Level.FINE, MESSAGE_LOG_REPLACED_CURRENT_DIRECTORY);
			this.setLatestDirectory();
			
			Display.setFeedBack(String.format(MESSAGE_FEEDBACK_SUCCESSFUL_DIRECTORY_CHANGE, directory.getPath()));
			
			logger.log(Level.FINE, MESSAGE_LOG_END_CHANGE_DIRECTORY);
			return true;
		}
		catch (SecurityException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_SECURITY_EXCEPTION);
			Display.setFeedBack(String.format(MESSAGE_FEEDBACK_SECURITY_EXCEPTION, input_NewDirectory));
			return false;
		}
		catch (NullPointerException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_NULL_POINTER_EXCEPTION);
			Display.setFeedBack(MESSAGE_FEEDBACK_NO_INPUT_DIRECTORY);
			return false;
		}
	}

	public boolean save(ArrayList<Task> taskList, boolean isDone) {
		assert taskList != null : MESSAGE_ASSERTION_NULL_PARAMETER;
		logger.log(Level.FINE, MESSAGE_LOG_SAVING_TEXTFILES);
		if (taskFile.writeToFile(taskList, isDone)) {
			logger.log(Level.FINE, MESSAGE_LOG_SUCCESSFULLY_SAVED_TEXTFILES);
			return true;
		}
		else {
			logger.log(Level.WARNING, MESSAGE_LOG_UNSUCCESSFULLY_SAVED_TEXTFILES);
			Display.setFeedBack(MESSAGE_FEEDBACK_SAVE_UNSUCCESSFUL);
			
			return false;
		}
	}

	public ArrayList<Task> load(boolean isDone) {
		logger.log(Level.FINE, MESSAGE_LOG_LOADING_TEXTFILES);
		return taskFile.readFromFile(isDone);
	}

	private File getLatestDirectory() {
		String newLine;
		File latestDirectory = null;
		try{
			logger.log(Level.FINER, MESSAGE_LOG_READING_LATEST_DIRECTORY);
			BufferedReader br = new BufferedReader(new FileReader(latestDirectoryTextFile));
			newLine = br.readLine();
			latestDirectory = gson.fromJson(newLine, File.class);
			logger.log(Level.FINER, MESSAGE_LOG_READ_LATEST_DIRECTORY);
			br.close();
		}
		catch (FileNotFoundException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_FILE_NOT_FOUND_EXCEPTION);
			return null;
		}
		catch (IOException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION);
			return null;
		}
		return latestDirectory;
	}
	
	/**
	 * Returns a boolean value depending on the success of setting the latest directory.
	 * This method writes the latest directory in which the textfiles were saved in, into "Latest directory.txt".
	 * 
	 * @param Void.
	 * @return	Boolean value indicating the success of setting the latest directory.
	 */
	private boolean setLatestDirectory() {
		try {
			logger.log(Level.FINER, MESSAGE_LOG_WRITING_LATEST_DIRECTORY);
			BufferedWriter bw = new BufferedWriter(new FileWriter(latestDirectoryTextFile));
			String json = gson.toJson(directory);
			bw.write(json);
			logger.log(Level.FINER, MESSAGE_LOG_WROTE_LATEST_DIRECTORY);
			bw.close();
			
			return true;
		}
		catch (IOException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION);
			return false;
		}
	}
	
	//For testing only.
	public void deleteAllFiles() {
		taskFile.getDoneFile().delete();
		taskFile.getUndoneFile().delete();
		getLatestDirectory().delete();
		latestDirectoryTextFile.delete();
	}
	
	// For testing only.
	public File getLatestDirectoryTextFile() {
		return latestDirectoryTextFile;
	}
}
```
###### src\storage\TaskStorage.java
``` java

package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.logging.*;

import com.google.gson.Gson;

import common.Task;

public class TaskStorage {
	// Attributes
	private File currentDirectory;
	private ArrayList<File> taskLists;
	private static Logger logger = Logger.getLogger("TaskStorage");
	
	// Logging Messages
	private static final String MESSAGE_LOG_START_SETLATESTFILES = "Obtained files in current directory, start setting latest files";
	private static final String MESSAGE_LOG_NO_FILES_FOUND_CREATING_DEFAULT = "No files were found in current directory, creating required default textfiles";
	private static final String MESSAGE_LOG_END_SETLATESTFILES = "End setting latest files";
	private static final String MESSAGE_LOG_START_ARRANGETASKLISTS = "Start arranging task lists";
	private static final String MESSAGE_LOG_BOTH_TEMPLISTS_EMPTY = "Both templists are empty";
	private static final String MESSAGE_LOG_TEMPLIST1_EMPTY = "Only tempList1 is empty";
	private static final String MESSAGE_LOG_TEMPLIST2_EMPTY = "Only tempList2 is empty";
	private static final String MESSAGE_LOG_END_ARRANGETASKLISTS = "End arranging task lists";
	private static final String MESSAGE_LOG_START_WRITETOFILE = "Start writing to file";
	private static final String MESSAGE_LOG_WRITING_TO_DONE_TEXTFILE = "Writing to done textfile";
	private static final String MESSAGE_LOG_WRITING_TO_UNDONE_TEXTFILE = "Writing to undone textfile";
	private static final String MESSAGE_LOG_END_WRITETOFILE = "End writing to file";
	private static final String MESSAGE_LOG_START_READFROMFILE = "Start reading from file";
	private static final String MESSAGE_LOG_READING_FROM_DONE_TEXTFILE = "Reading from done textfile";
	private static final String MESSAGE_LOG_READING_FROM_UNDONE_TEXTFILE = "Reading from undone textfile";
	private static final String MESSAGE_LOG_FILE_NOT_FOUND_EXCEPTION = "File not found exception encountered";
	private static final String MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION = "Input output exception encountered";
	private static final String MESSAGE_LOG_END_READFROMFILE = "End reading from file";
	private static final String MESSAGE_LOG_START_MOVEFILES = "Start moving files";
	private static final String MESSAGE_LOG_RENAMING_FILES = "Renaming files";
	private static final String MESSAGE_LOG_END_MOVEFILES = "End moving files";
	
	// Assertion Messages
	private static final String MESSAGE_ASSERTION_NULL_PARAMETER = "StorageControl error. Null input passed in as parameter!";
	private static final String MESSAGE_ASSERTION_INVALID_NUMBER_OF_FILES = "Invalid number of files in current directory";
	
	protected TaskStorage(File directory) {
		taskLists = new ArrayList<File>();
		currentDirectory = directory;
		setLatestFiles(currentDirectory);
	}
	
	/**
	 * Sets the current textfiles being tracked in the data structure.
	 * Default textfiles are created and tracked if no existing textfiles were found in the current directory.
	 * 
	 * @param The current directory in which the textfiles are saved.
	 * @return	Void.
	 */
	private void setLatestFiles(File currentDirectory) {
		assert currentDirectory != null : MESSAGE_ASSERTION_NULL_PARAMETER;
		File[] listOfFiles = currentDirectory.listFiles();
		assert (listOfFiles.length == 2 || listOfFiles.length == 0) : MESSAGE_ASSERTION_INVALID_NUMBER_OF_FILES;
		logger.log(Level.FINE, MESSAGE_LOG_START_SETLATESTFILES);
		
		if (listOfFiles.length == 0) {
			logger.log(Level.INFO, MESSAGE_LOG_NO_FILES_FOUND_CREATING_DEFAULT);
			taskLists.add(new File(currentDirectory, "Undone tasks.txt"));
			taskLists.add(new File(currentDirectory, "Done tasks.txt"));
			
			try {
				taskLists.get(0).createNewFile();
				taskLists.get(1).createNewFile();
			}
			catch (IOException e) {
				logger.log(Level.WARNING, MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION);
				e.printStackTrace();
			}
			
			return;
		}
		
		taskLists.clear();
		taskLists.add(listOfFiles[0]);
		taskLists.add(listOfFiles[1]);
		
		arrangeTaskLists();
		logger.log(Level.FINE, MESSAGE_LOG_END_SETLATESTFILES);
	}
	
	/**
	 * Arranges the files saved in ArrayList<File> taskLists to ensure that the undone file has index 0
	 * and the done file has index 1.
	 * 
	 * @param Void.
	 * @return	Void.
	 */
	private void arrangeTaskLists() {
		logger.log(Level.FINE, MESSAGE_LOG_START_ARRANGETASKLISTS);
		ArrayList<Task> tempList1 = new ArrayList<Task>();
		ArrayList<Task> tempList2 = new ArrayList<Task>();
		tempList1 = readFromFile(false);
		tempList2 = readFromFile(true);
		
		if (tempList1.isEmpty() == true && tempList2.isEmpty() == true) {
			logger.log(Level.FINE, MESSAGE_LOG_BOTH_TEMPLISTS_EMPTY);
			if (taskLists.get(0).getName().equalsIgnoreCase("Done tasks.txt")) {
				taskLists.add(taskLists.get(0));
				taskLists.set(0, taskLists.get(1));
				taskLists.set(1, taskLists.get(2));
				taskLists.remove(2);
			}
			else {
				logger.log(Level.FINE, MESSAGE_LOG_END_ARRANGETASKLISTS);
				return;
			}
		}
		else if (tempList1.isEmpty() == true) {
			logger.log(Level.FINE, MESSAGE_LOG_TEMPLIST1_EMPTY);
			if (tempList2.get(0).getDoneStatus() == true) {
				logger.log(Level.FINE, MESSAGE_LOG_END_ARRANGETASKLISTS);
				return;
			}
			else {
				taskLists.add(taskLists.get(0));
				taskLists.set(0, taskLists.get(1));
				taskLists.set(1, taskLists.get(2));
				taskLists.remove(2);
			}
		}
		else {
			logger.log(Level.FINE, MESSAGE_LOG_TEMPLIST2_EMPTY);
			if (tempList1.get(0).getDoneStatus() == true) {
				taskLists.add(taskLists.get(0));
				taskLists.set(0, taskLists.get(1));
				taskLists.set(1, taskLists.get(2));
				taskLists.remove(2);
			}
			else {
				logger.log(Level.FINE, MESSAGE_LOG_END_ARRANGETASKLISTS);
				return;
			}
		}
		logger.log(Level.FINE, MESSAGE_LOG_END_ARRANGETASKLISTS);
	}
	
	protected boolean writeToFile(ArrayList<Task> taskList, boolean isDone) {
		assert taskList != null : MESSAGE_ASSERTION_NULL_PARAMETER;
		logger.log(Level.FINER, MESSAGE_LOG_START_WRITETOFILE);
		setLatestFiles(currentDirectory);
		try {
			BufferedWriter bw;
			if (isDone == true) {
				logger.log(Level.FINER, MESSAGE_LOG_WRITING_TO_DONE_TEXTFILE);
				bw = new BufferedWriter(new FileWriter(taskLists.get(1)/*taskFile_Done*/));
			}
			else {
				logger.log(Level.FINER, MESSAGE_LOG_WRITING_TO_UNDONE_TEXTFILE);
				bw = new BufferedWriter(new FileWriter(taskLists.get(0)/*taskFile_Undone*/));
			}
			for (Task task: taskList) {
				performWriting(bw, task);
			}
			bw.close();
			
			logger.log(Level.FINER, MESSAGE_LOG_END_WRITETOFILE);
			return true;
		}
		catch (IOException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION);
			e.printStackTrace();
			return false;
		}
	}
	
	protected ArrayList<Task> readFromFile(boolean isDone) {
		logger.log(Level.FINER, MESSAGE_LOG_START_READFROMFILE);
		ArrayList<Task> new_TaskList = new ArrayList<Task>();
		String newLine = "";
		Gson gsonRead = new Gson();
		try{
			BufferedReader br;
			if (isDone == true) {
				logger.log(Level.FINER, MESSAGE_LOG_READING_FROM_DONE_TEXTFILE);
				br = new BufferedReader(new FileReader(taskLists.get(1)));
			}
			else {
				logger.log(Level.FINER, MESSAGE_LOG_READING_FROM_UNDONE_TEXTFILE);
				br = new BufferedReader(new FileReader(taskLists.get(0)));
				
			}
			while ((newLine = br.readLine()) != null) {
				new_TaskList.add(gsonRead.fromJson(newLine, Task.class));
			}
			br.close();
		}
		catch (FileNotFoundException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_FILE_NOT_FOUND_EXCEPTION);
			return new ArrayList<Task>();
		}
		catch (IOException e) {
			logger.log(Level.WARNING, MESSAGE_LOG_INPUT_OUTPUT_EXCEPTION);
			e.printStackTrace();
			return null;
		}
		
		logger.log(Level.FINER, MESSAGE_LOG_END_READFROMFILE);
		return new_TaskList;
	}
	
	private String performWriting(BufferedWriter bw, Task task) throws IOException {
		Gson gsonWrite = new Gson();
		String json = gsonWrite.toJson(task) + "\n";
		bw.write(json);
		
		return json;
	}
	
	/**
	 * Moves the textfiles from the current directory to the new directory specified by newDirectory.
	 * 
	 * 
	 * @param The new directory in which the textfiles are to be saved.
	 * @return	Void.
	 */
	protected void moveFiles(File newDirectory) {
		assert newDirectory != null : MESSAGE_ASSERTION_NULL_PARAMETER;
		logger.log(Level.FINER, MESSAGE_LOG_START_MOVEFILES);
		setLatestFiles(currentDirectory);
		currentDirectory = newDirectory;
		
		File newUndoneTasks = new File(newDirectory.getPath() + "\\" + taskLists.get(0).getName());
		File newDoneTasks = new File(newDirectory.getPath() + "\\" + taskLists.get(1).getName());
		
		logger.log(Level.FINER, MESSAGE_LOG_RENAMING_FILES);
		getUndoneFile().renameTo(newUndoneTasks);
		getDoneFile().renameTo(newDoneTasks);
		logger.log(Level.FINER, MESSAGE_LOG_END_MOVEFILES);
	}
	
	protected File getUndoneFile() {
		return taskLists.get(0);
	}
	
	protected File getDoneFile() {
		return taskLists.get(1);
	}
	
	protected void setUndoneFile(File taskFile) {
		taskLists.set(0, taskFile);
	}
	
	protected void setDoneFile(File taskFile) {
		taskLists.set(1, taskFile);
	}
}
```
###### src\tests\AddCommandTest.java
``` java

package tests;

import static org.junit.Assert.*;

import logic.AddCommand;
import logic.TaskManager;
import storage.StorageControl;
import common.Task;
import common.TaskType;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.SortedMap;

import org.junit.Test;

public class AddCommandTest {

	@Test
	public void execute_NonBoundary_FloatingTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing");
		
		assertEquals(testAddCommand.execute(testTask), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(false);
		assertEquals(testFloatingList.get(0), testTask);
	}
	
	@Test
	public void execute_NonBoundary_EventTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		
		assertEquals(testAddCommand.execute(testTask), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.get(LocalDate.of(2015, 12, 20)).toString(), "[" + testTask.toString() + "]");
	}
	
	@Test
	public void execute_NonBoundary_TodoTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), TaskType.TODO);
		
		assertEquals(testAddCommand.execute(testTask), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.get(LocalDate.of(2015, 12, 20)).toString(), "[" + testTask.toString() + "]");
	}
	
	@Test
	public void execute_NonBoundary_DeadlineTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), TaskType.DEADLINE);
		
		assertEquals(testAddCommand.execute(testTask), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.get(LocalDate.of(2015, 12, 20)).toString(), "[" + testTask.toString() + "]");
	}
	
	@Test
	public void execute_Boundary_Null() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = null;
		assertEquals(testAddCommand.execute(testTask), false);
	}
	
	@Test
	public void execute_Boundary_RepeatedTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		
		assertEquals(testAddCommand.execute(testTask), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.get(LocalDate.of(2015, 12, 20)).toString(), "[" + testTask.toString() + "]");
		
		assertEquals(testAddCommand.execute(testTask), false);
	}

}
```
###### src\tests\CommandStackTest.java
``` java

package tests;

import static org.junit.Assert.*;

import logic.AddCommand;
import logic.CommandStack;
import logic.DeleteCommand;
import logic.DoneCommand;
import logic.EditCommand;
import logic.TaskManager;
import storage.StorageControl;
import common.Task;
import common.TaskType;
import common.Pair;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.SortedMap;

import org.junit.Test;

public class CommandStackTest {

	 /**
	  * Has been commented out as a test method had to be put in
	  * CommandStack in order for effective testing. When not
	  *  testing, this test method is commented out. Thus, this 
	  *	Junit has to be commented out as well.
	  *
	  * Please uncomment the test methods in CommandStack if you would
	  * like to use this JUnit test.
	  */
/*	@Test
	public void addCommand_NonBoundary_SingleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		CommandStack testCommandStack = new CommandStack();
		
		testCommandStack.addCommand(testAddCommand);
		
		assertEquals(testCommandStack.getUndoStack().size(), 1);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
	}
	
	@Test
	public void addCommand_NonBoundary_MultipleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand1 = new AddCommand(testManager);
		AddCommand testAddCommand2 = new AddCommand(testManager);
		AddCommand testAddCommand3 = new AddCommand(testManager);
		
		CommandStack testCommandStack = new CommandStack();
		
		testCommandStack.addCommand(testAddCommand1);
		testCommandStack.addCommand(testAddCommand2);
		testCommandStack.addCommand(testAddCommand3);
		
		assertEquals(testCommandStack.getUndoStack().size(), 3);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
	}
	
	@Test
	public void undoOperation_NonBoundary_UndoSingleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing");
		CommandStack testCommandStack = new CommandStack();
		
		testAddCommand.execute(testTask);
		testCommandStack.addCommand(testAddCommand);
		
		assertEquals(testCommandStack.getUndoStack().size(), 1);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
		
		assertEquals(testCommandStack.undoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().isEmpty(), true);
		assertEquals(testCommandStack.getRedoStack().size(), 1);
	}
	
	@Test
	public void undoOperation_NonBoundary_UndoMultipleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand1 = new AddCommand(testManager);
		AddCommand testAddCommand2 = new AddCommand(testManager);
		AddCommand testAddCommand3 = new AddCommand(testManager);
		Task testTask1 = new Task("testing1");
		Task testTask2 = new Task("testing2");
		Task testTask3 = new Task("testing3");
		CommandStack testCommandStack = new CommandStack();
		
		testAddCommand1.execute(testTask1);
		testCommandStack.addCommand(testAddCommand1);
		testAddCommand2.execute(testTask2);
		testCommandStack.addCommand(testAddCommand2);
		testAddCommand3.execute(testTask3);
		testCommandStack.addCommand(testAddCommand3);
		
		assertEquals(testCommandStack.getUndoStack().size(), 3);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
		
		assertEquals(testCommandStack.undoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 2);
		assertEquals(testCommandStack.getRedoStack().size(), 1);
		
		assertEquals(testCommandStack.undoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 1);
		assertEquals(testCommandStack.getRedoStack().size(), 2);
		
		assertEquals(testCommandStack.undoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().isEmpty(), true);
		assertEquals(testCommandStack.getRedoStack().size(), 3);
	}
	
	@Test
	public void addCommand_NonBoundary_RedoSingleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		Task testTask = new Task("testing");
		CommandStack testCommandStack = new CommandStack();
		
		testAddCommand.execute(testTask);
		testCommandStack.addCommand(testAddCommand);
		testCommandStack.undoOperation();
		
		assertEquals(testCommandStack.redoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 1);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
	}
	
	@Test
	public void redoOperation_NonBoundary_RedoMultipleCommand() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand1 = new AddCommand(testManager);
		AddCommand testAddCommand2 = new AddCommand(testManager);
		AddCommand testAddCommand3 = new AddCommand(testManager);
		Task testTask1 = new Task("testing1");
		Task testTask2 = new Task("testing2");
		Task testTask3 = new Task("testing3");
		CommandStack testCommandStack = new CommandStack();
		
		testAddCommand1.execute(testTask1);
		testCommandStack.addCommand(testAddCommand1);
		testAddCommand2.execute(testTask2);
		testCommandStack.addCommand(testAddCommand2);
		testAddCommand3.execute(testTask3);
		testCommandStack.addCommand(testAddCommand3);

		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		
		assertEquals(testCommandStack.redoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 1);
		assertEquals(testCommandStack.getRedoStack().size(), 2);
		
		assertEquals(testCommandStack.redoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 2);
		assertEquals(testCommandStack.getRedoStack().size(), 1);
		
		assertEquals(testCommandStack.redoOperation(), true);
		assertEquals(testCommandStack.getUndoStack().size(), 3);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
	}
	
	@Test
	public void addCommand_Boundary_MultipleCommandExceed5() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand1 = new AddCommand(testManager);
		AddCommand testAddCommand2 = new AddCommand(testManager);
		AddCommand testAddCommand3 = new AddCommand(testManager);
		AddCommand testAddCommand4 = new AddCommand(testManager);
		AddCommand testAddCommand5 = new AddCommand(testManager);
		AddCommand testAddCommand6 = new AddCommand(testManager);
		
		CommandStack testCommandStack = new CommandStack();
		
		testCommandStack.addCommand(testAddCommand1);
		testCommandStack.addCommand(testAddCommand2);
		testCommandStack.addCommand(testAddCommand3);
		testCommandStack.addCommand(testAddCommand4);
		testCommandStack.addCommand(testAddCommand5);
		testCommandStack.addCommand(testAddCommand6);
		
		assertEquals(testCommandStack.getUndoStack().size(), 5);
		assertEquals(testCommandStack.getRedoStack().isEmpty(), true);
	}
	
	@Test
	public void undoOperation_Boundary_UndoMultipleCommandExceed5() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand1 = new AddCommand(testManager);
		AddCommand testAddCommand2 = new AddCommand(testManager);
		AddCommand testAddCommand3 = new AddCommand(testManager);
		AddCommand testAddCommand4 = new AddCommand(testManager);
		AddCommand testAddCommand5 = new AddCommand(testManager);
		AddCommand testAddCommand6 = new AddCommand(testManager);
		Task testTask1 = new Task("testing1");
		Task testTask2 = new Task("testing2");
		Task testTask3 = new Task("testing3");
		Task testTask4 = new Task("testing4");
		Task testTask5 = new Task("testing5");
		Task testTask6 = new Task("testing6");
		CommandStack testCommandStack = new CommandStack();
		
		testAddCommand1.execute(testTask1);
		testCommandStack.addCommand(testAddCommand1);
		testAddCommand2.execute(testTask2);
		testCommandStack.addCommand(testAddCommand2);
		testAddCommand3.execute(testTask3);
		testCommandStack.addCommand(testAddCommand3);
		testAddCommand4.execute(testTask4);
		testCommandStack.addCommand(testAddCommand4);
		testAddCommand5.execute(testTask5);
		testCommandStack.addCommand(testAddCommand5);
		testAddCommand6.execute(testTask6);
		testCommandStack.addCommand(testAddCommand6);
		
		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		testCommandStack.undoOperation();
		assertEquals(testCommandStack.undoOperation(), false);
		assertEquals(testCommandStack.getRedoStack().size(), 5);
	}
	
	@Test
	public void undoOperation_Boundary_NullCommandUndo() {
		CommandStack testCommandStack = new CommandStack();
		
		assertEquals(testCommandStack.getUndoStack().isEmpty(), true);
		assertEquals(testCommandStack.undoOperation(), false);
	}
	
	@Test
	public void undoOperation_Boundary_NullCommandRedo() {
		CommandStack testCommandStack = new CommandStack();
		
		assertEquals(testCommandStack.getUndoStack().isEmpty(), true);
		assertEquals(testCommandStack.redoOperation(), false);
	}*/
}
```
###### src\tests\DeleteCommandTest.java
``` java

package tests;

import static org.junit.Assert.*;

import logic.AddCommand;
import logic.DeleteCommand;
import logic.TaskManager;
import storage.StorageControl;
import common.Task;
import common.Pair;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.SortedMap;

import org.junit.Test;

public class DeleteCommandTest {

	@Test
	public void execute_NonBoundary_SingleFloatingTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DeleteCommand testDeleteCommand = new DeleteCommand(testManager);
		Task testTask = new Task("testing");
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(null, testIndexArrayList);
		
		testAddcommand.execute(testTask);
		assertEquals(testDeleteCommand.execute(testPair), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(false);
		assertEquals(testFloatingList.isEmpty(), true);
	}
	
	@Test
	public void execute_NonBoundary_SingleDatedTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DeleteCommand testDeleteCommand = new DeleteCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(LocalDate.of(2015, 12, 20), testIndexArrayList);
		
		testAddcommand.execute(testTask);
		assertEquals(testDeleteCommand.execute(testPair), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.isEmpty(), true);
	}
	
	@Test
	public void execute_NonBoundary_MultiFloatingTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DeleteCommand testDeleteCommand = new DeleteCommand(testManager);
		Task testTask1 = new Task("testing1");
		Task testTask2 = new Task("testing2");
		Task testTask3 = new Task("testing3");
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		testIndexArrayList.add(2);
		testIndexArrayList.add(3);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(null, testIndexArrayList);
		
		testAddcommand.execute(testTask1);
		testAddcommand.execute(testTask2);
		testAddcommand.execute(testTask3);
		assertEquals(testDeleteCommand.execute(testPair), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(false);
		assertEquals(testFloatingList.isEmpty(), true);
	}
	
	@Test
	public void execute_NonBoundary_MultiDatedTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DeleteCommand testDeleteCommand = new DeleteCommand(testManager);
		Task testTask1 = new Task("testing1", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		Task testTask2 = new Task("testing2", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 26), LocalTime.of(19, 30));
		Task testTask3 = new Task("testing3", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 27), LocalTime.of(20, 30));
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		testIndexArrayList.add(2);
		testIndexArrayList.add(3);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(LocalDate.of(2015, 12, 20), testIndexArrayList);
		
		testAddcommand.execute(testTask1);
		testAddcommand.execute(testTask2);
		testAddcommand.execute(testTask3);
		assertEquals(testDeleteCommand.execute(testPair), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.isEmpty(), true);
	}
	
	@Test
	public void execute_Boundary_Null() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		DeleteCommand testDeleteCommand = new DeleteCommand(testManager);
		Pair<LocalDate, ArrayList<Integer>> testPair = null;
		
		assertEquals(testDeleteCommand.execute(testPair), false);
	}
}
```
###### src\tests\DoneCommandTest.java
``` java

package tests;

import static org.junit.Assert.*;

import logic.AddCommand;
import logic.DoneCommand;
import logic.TaskManager;
import storage.StorageControl;
import common.Task;
import common.Pair;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.SortedMap;

import org.junit.Test;

public class DoneCommandTest {

	@Test
	public void execute_NonBoundary_SingleFloatingTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DoneCommand testDoneCommand = new DoneCommand(testManager);
		Task testTask = new Task("testing");
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(null, testIndexArrayList);
		
		testAddcommand.execute(testTask);
		assertEquals(testDoneCommand.execute(testPair), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(true);
		assertEquals(testFloatingList.get(0), testTask);
	}
	
	@Test
	public void execute_NonBoundary_SingleDatedTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DoneCommand testDoneCommand = new DoneCommand(testManager);
		Task testTask = new Task("testing", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(LocalDate.of(2015, 12, 20), testIndexArrayList);
		
		testAddcommand.execute(testTask);
		assertEquals(testDoneCommand.execute(testPair), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(true);
		assertEquals(testDatedList.get(LocalDate.of(2015,  12,  20)).toString(), "[" + testTask.toString() + "]");
	}
	
	@Test
	public void execute_NonBoundary_MultiFloatingTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		DoneCommand testDoneCommand = new DoneCommand(testManager);
		Task testTask1 = new Task("testing1");
		Task testTask2 = new Task("testing2");
		Task testTask3 = new Task("testing3");
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		testIndexArrayList.add(2);
		testIndexArrayList.add(3);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(null, testIndexArrayList);
		
		testAddCommand.execute(testTask1);
		testAddCommand.execute(testTask2);
		testAddCommand.execute(testTask3);
		assertEquals(testDoneCommand.execute(testPair), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(true);
		assertEquals(testFloatingList.get(0), testTask1);
		assertEquals(testFloatingList.get(1), testTask2);
		assertEquals(testFloatingList.get(2), testTask3);
	}
	
	@Test
	public void execute_NonBoundary_MultiDatedTask() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddcommand = new AddCommand(testManager);
		DoneCommand testDoneCommand = new DoneCommand(testManager);
		Task testTask1 = new Task("testing1", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		Task testTask2 = new Task("testing2", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 26), LocalTime.of(19, 30));
		Task testTask3 = new Task("testing3", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 27), LocalTime.of(20, 30));
		ArrayList<Integer> testIndexArrayList = new ArrayList<Integer>();
		testIndexArrayList.add(1);
		testIndexArrayList.add(2);
		testIndexArrayList.add(3);
		Pair<LocalDate, ArrayList<Integer>> testPair = new Pair<LocalDate, ArrayList<Integer>>(LocalDate.of(2015, 12, 20), testIndexArrayList);
		
		testAddcommand.execute(testTask1);
		testAddcommand.execute(testTask2);
		testAddcommand.execute(testTask3);
		assertEquals(testDoneCommand.execute(testPair), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(true);
		assertEquals(testDatedList.isEmpty(), false);
	}
	
	@Test
	public void execute_Boundary_Null() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		DoneCommand testDoneCommand = new DoneCommand(testManager);
		Pair<LocalDate, ArrayList<Integer>> testPair = null;
		
		assertEquals(testDoneCommand.execute(testPair), false);
	}
}
```
###### src\tests\EditCommandTest.java
``` java

package tests;

import static org.junit.Assert.*;

import logic.AddCommand;
import logic.EditCommand;
import logic.TaskManager;
import storage.StorageControl;
import common.Task;
import common.Pair;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.SortedMap;

import org.junit.Test;

public class EditCommandTest {

	@Test
	public void execute_NonBoundary_FloatingPair() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		EditCommand testEditCommand = new EditCommand(testManager);
		Task testUnmodifiedTask = new Task("testing unmodified");
		Task testModifiedTask = new Task("testing modified");
		Pair<Task, Task> testPair = new Pair<Task, Task>(testUnmodifiedTask, testModifiedTask);
		
		assertEquals(testEditCommand.execute(testPair), true);
		
		ArrayList<Task> testFloatingList;
		testFloatingList = testManager.getFloating(false);
		assertEquals(testFloatingList.get(0), testModifiedTask);
	}
	
	@Test
	public void execute_NonBoundary_EventPair() {
		StorageControl testStorageControl = new StorageControl();
		TaskManager testManager = new TaskManager(testStorageControl);
		AddCommand testAddCommand = new AddCommand(testManager);
		EditCommand testEditCommand = new EditCommand(testManager);
		Task testUnmodifiedTask = new Task("testing unmodified", LocalDate.of(2015, 12, 20), LocalTime.of(10, 15), LocalDate.of(2015, 12, 25), LocalTime.of(18, 30));
		Task testModifiedTask = new Task("testing modified", LocalDate.of(2014, 11, 19), LocalTime.of(9, 14), LocalDate.of(2014, 11, 24), LocalTime.of(17, 29));
		Pair<Task, Task> testPair = new Pair<Task, Task>(testUnmodifiedTask, testModifiedTask);
		
		testAddCommand.execute(testUnmodifiedTask);
		assertEquals(testEditCommand.execute(testPair), true);
		
		SortedMap<LocalDate, ArrayList<Task>> testDatedList;
		testDatedList = testManager.getDated(false);
		assertEquals(testDatedList.get(LocalDate.of(2014, 11, 19)).toString(), "[" + testModifiedTask.toString() + "]");
	}
}
```
###### src\tests\SingleDateParserTest_Dash.java
``` java

package tests;

import static org.junit.Assert.*;
import java.time.LocalDate;

import org.junit.Test;

import parser.SingleDateParser;

public class SingleDateParserTest_Dash {

	@Test
	public void test_Parse_DashCase1() { // dd-MM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + "0" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase2() { // d-MM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + "0" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	@Test
	public void test_Parse_DashCase3() { // dd-M-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase4() { // d-M-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase5() { // dd-MMM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase6() { // d-MMM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase7() { // dd-MM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + "0" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase8() { // d-MM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {			
					if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + "0" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase9() { // dd-M-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase10() { // d-M-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + Integer.toString(month) +
								"-" + Integer.toString(year)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase11() { // dd-MMM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase12() { // d-MMM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase13() { // d-MMMM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase14() { // dd-MMMM-yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase15() { // dd-MMMM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_DashCase16() { // d-MMMM-yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
}
```
###### src\tests\SingleDateParserTest_NaturalLanguage.java
``` java

package tests;

import static org.junit.Assert.*;

import org.junit.Test;

import parser.SingleDateParser;

import java.time.LocalDate;

public class SingleDateParserTest_NaturalLanguage {

	//@Test
	public void test_Parse_TestCase1() {
		SingleDateParser dateParser = new SingleDateParser();
		String[] listOfWords = {"Today", "tonight", "nOw", "toMOrrOW"};
		
		assertEquals(dateParser.parse(listOfWords[0]), LocalDate.now());
		assertEquals(dateParser.parse(listOfWords[1]), LocalDate.now());
		assertEquals(dateParser.parse(listOfWords[2]), LocalDate.now());
		assertEquals(dateParser.parse(listOfWords[3]), LocalDate.now().plusDays(1));
	}
	
	//@Test
	public void test_Parse_TestCase2() { //As tested on 30 September 2015, Wednesday
		SingleDateParser dateParser = new SingleDateParser();
		/*String[] listOfWords = {"This", "Next"};
		String[] listOfTimePeriods = {"Week", "month", "yeAR"};
		String[] listOfDays = {"Monday", "tuesday", "WednesDay", "ThuRSDAY", "FRiDaY", "SaturdAY", "SUNDAy"};
		LocalDate today = LocalDate.of(2015, 9, 29);*/
	
		assertEquals(dateParser.parse("this monday"), LocalDate.now().plusDays(5));	
		assertEquals(dateParser.parse("this tuesday"), LocalDate.now().plusDays(6));
		assertEquals(dateParser.parse("this wednesday"), LocalDate.now().plusDays(0));
		assertEquals(dateParser.parse("this thursday"), LocalDate.now().plusDays(1));
		assertEquals(dateParser.parse("this friday"), LocalDate.now().plusDays(2));
		assertEquals(dateParser.parse("this saturday"), LocalDate.now().plusDays(3));
		assertEquals(dateParser.parse("this sunday"), LocalDate.now().plusDays(4));
		
		assertEquals(dateParser.parse("next monday"), LocalDate.now().plusDays(5));
		assertEquals(dateParser.parse("next tuesday"), LocalDate.now().plusDays(6));
		assertEquals(dateParser.parse("next wednesday"), LocalDate.now().plusDays(7));
		assertEquals(dateParser.parse("next thursday"), LocalDate.now().plusDays(8));
		assertEquals(dateParser.parse("next friday"), LocalDate.now().plusDays(9));
		assertEquals(dateParser.parse("next saturday"), LocalDate.now().plusDays(10));
		assertEquals(dateParser.parse("next sunday"), LocalDate.now().plusDays(11));	
	}
	
	//@Test
	public void test_Parse_TestCase3() { //As tested on 30 September 2015, Wednesday
		SingleDateParser dateParser = new SingleDateParser();
		/*String[] listOfWords = {"This", "Next"};
		String[] listOfTimePeriods = {"Week", "month", "yeAR"};
		String[] listOfDays = {"Monday", "tuesday", "WednesDay", "ThuRSDAY", "FRiDaY", "SaturdAY", "SUNDAy"};
		LocalDate today = LocalDate.of(2015, 9, 29);*/
	
		assertEquals(dateParser.parse("next week"), LocalDate.now().plusWeeks(1));	
		assertEquals(dateParser.parse("next month"), LocalDate.now().plusMonths(1));
		assertEquals(dateParser.parse("next year"), LocalDate.now().plusYears(1));
	}
	
	@Test
```
###### src\tests\SingleDateParserTest_Slash.java
``` java

package tests;

import static org.junit.Assert.*;
import java.time.LocalDate;

import org.junit.Test;

import parser.SingleDateParser;

public class SingleDateParserTest_Slash {

	@Test
	public void test_Parse_SlashCase1() { // dd/MM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + "0" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase2() { // d/MM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + "0" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	@Test
	public void test_Parse_SlashCase3() { // dd/M/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase4() { // d/M/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase5() { // dd/MMM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase6() { // d/MMM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase7() { // dd/MM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + "0" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase8() { // d/MM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {			
					if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + "0" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase9() { // dd/M/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase10() { // d/M/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "/" + Integer.toString(month) +
								"/" + Integer.toString(year)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase11() { // dd/MMM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SlashCase12() { // d/MMM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "/" + month[j - 1] +
								"/" + Integer.toString(year)), LocalDate.of(year, j, day));	
				}
			}
		}
	}

	@Test
	public void test_Parse_SlashCase13() { // d/MMMM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
							"-" + Integer.toString(year)), LocalDate.of(year, j, day));
				}
			}
		}
	}

	@Test
	public void test_Parse_SlashCase14() { // dd/MMMM/yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}

	@Test
	public void test_Parse_SlashCase15() { // dd/MMMM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}

					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}

	@Test
	public void test_Parse_SlashCase16() { // d/MMMM/yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
							"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
}
```
###### src\tests\SingleDateParserTest_Space.java
``` java

package tests;

import static org.junit.Assert.*;
import java.time.LocalDate;

import org.junit.Test;

import parser.SingleDateParser;

public class SingleDateParserTest_Space {

	@Test
	public void test_Parse_SpaceCase1() { // dd MM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + " " + "0" + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase2() { // d MM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + " " + "0" + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	@Test
	public void test_Parse_SpaceCase3() { // dd M yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase4() { // d M yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase5() { // dd MMM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase6() { // d MMM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};
		
		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase7() { // dd MM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + " " + "0" + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase8() { // d MM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;
		
		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 12; month++) {
				for (day = 1; day <= 9; day++) {			
					if (month < 10){
						assertEquals(dateParser.parse(Integer.toString(day) + " " + "0" + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase9() { // dd M yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && month == 4) || (day == 31 && month == 6) || (day == 31 && month == 9) || (day == 31 && month == 11)
							|| (day > 28 && month == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase10() { // d M yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, month, year;

		for (year = 2016; year <= 2099; year++) {
			for (month = 1; month <= 9; month++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + " " + Integer.toString(month) +
								" " + Integer.toString(year)), LocalDate.of(year, month, day));
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase11() { // dd MMM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}
	
	@Test
	public void test_Parse_SpaceCase12() { // d MMM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"Jan", "feb", "MAR", "ApR", "mAy", "juN", "JUl", "auG", "Sep", "OcT", "nOv", "DEC"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + " " + month[j - 1] +
								" " + Integer.toString(year)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
	
	//@Test
	public void test_Parse_SpaceCase13() { // d MMMM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
							"-" + Integer.toString(year)), LocalDate.of(year, j, day));
				}
			}
		}
	}

	@Test
	public void test_Parse_SpaceCase14() { // dd MMMM yyyy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}
					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}

	@Test
	public void test_Parse_SpaceCase15() { // dd MMMM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 31; day++) {
					if ((day == 31 && j == 4) || (day == 31 && j == 6) || (day == 31 && j == 9) || (day == 31 && j == 11)
							|| (day > 28 && j == 2)) {
						continue;
					}

					else if (day < 10) {
						assertEquals(dateParser.parse("0" + Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}
					else {
						assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
								"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));
					}	
				}
			}
		}
	}

	@Test
	public void test_Parse_SpaceCase16() { // d MMMM yy
		SingleDateParser dateParser = new SingleDateParser();
		int day, year;
		String[] month = {"January", "february", "MARCH", "ApRiL", "mAy", "juNe", "JUly", "auGUST", "SepTemBER", "OcTobeR", "nOvEMBEr", "DECembeR"};

		for (year = 2016; year <= 2099; year++) {
			for (int j = 1; j <= month.length; j++) {
				for (day = 1; day <= 9; day++) {
					assertEquals(dateParser.parse(Integer.toString(day) + "-" + month[j - 1] +
							"-" + Integer.toString(year).substring(2)), LocalDate.of(year, j, day));	
				}
			}
		}
	}
}
```
###### src\tests\SingleTimeParserTest_Colon.java
``` java

package tests;

import static org.junit.Assert.*;
import org.junit.Test;

import parser.SingleTimeParser;

import java.time.LocalTime;

public class SingleTimeParserTest_Colon {

	//@Test
	public void test_Parse_ColonCase1() { // h:mma
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 1; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
				}
			}
		}

		for (hour = 1; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
			}
		}
	}

	//@Test
	public void test_Parse_ColonCase2() { // hh:mma
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 1; hour <= 11; hour++) {
			for (min = 0; min <= 59; min++) {
				if (hour < 10) {
					if (min < 10) {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + ":" + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + ":" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
				}
				else {
					if (min < 10) {
						assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
				}
			}
		}

		for (hour = 1; hour <= 11; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
			}
		}

		assertEquals(timeParser.parse("12:00am"), LocalTime.of(0, 0));
		assertEquals(timeParser.parse("12:00pm"), LocalTime.of(12, 0));
	}

	@Test
	public void test_Parse_ColonCase3() { // h:mm
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 0; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min)), LocalTime.of(hour, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min)), LocalTime.of(hour, min));
				}
			}
		}
	}

	@Test
	public void test_Parse_ColonCase4() { // hh:mm
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 0; hour <= 12; hour++) {
			for (min = 0; min <= 59; min++) {
				if (hour < 10) {
					if (min < 10) {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + ":" + "0" + Integer.toString(min)), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + ":" + Integer.toString(min)), LocalTime.of(hour, min));
					}
				}
				else {
					if (min < 10) {
						assertEquals(timeParser.parse(Integer.toString(hour) + ":" + "0" + Integer.toString(min)), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse(Integer.toString(hour) + ":" + Integer.toString(min)), LocalTime.of(hour, min));
					}
				}
			}
		}
	}
}
```
###### src\tests\SingleTimeParserTest_Dot.java
``` java

package tests;

import static org.junit.Assert.*;
import org.junit.Test;

import parser.SingleTimeParser;

import java.time.LocalTime;

public class SingleTimeParserTest_Dot {

	@Test
	public void test_Parse_DotCase1() { // h.mma
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 1; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min) + "am"), LocalTime.of(hour, min));
				}
			}
		}

		for (hour = 1; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
			}
		}
	}

	@Test
	public void test_Parse_DotCase2() { // hh.mma
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 1; hour <= 11; hour++) {
			for (min = 0; min <= 59; min++) {
				if (hour < 10) {
					if (min < 10) {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + "." + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + "." + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
				}
				else {
					if (min < 10) {
						assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min) + "am"), LocalTime.of(hour, min));
					}
				}
			}
		}

		for (hour = 1; hour <= 11; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min) + "pm"), LocalTime.of(hour + 12, min));
				}
			}
		}

		assertEquals(timeParser.parse("12:00am"), LocalTime.of(0, 0));
		assertEquals(timeParser.parse("12:00pm"), LocalTime.of(12, 0));
	}

	@Test
	public void test_Parse_DotCase3() { // h.mm
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 0; hour <= 9; hour++) {
			for (min = 0; min <= 59; min++) {
				if (min < 10) {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min)), LocalTime.of(hour, min));
				}
				else {
					assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min)), LocalTime.of(hour, min));
				}
			}
		}
	}

	@Test
	public void test_Parse_DotCase4() { // hh.mm
		int hour, min;
		SingleTimeParser timeParser = new SingleTimeParser();

		for (hour = 0; hour <= 12; hour++) {
			for (min = 0; min <= 59; min++) {
				if (hour < 10) {
					if (min < 10) {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + "." + "0" + Integer.toString(min)), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse("0" + Integer.toString(hour) + "." + Integer.toString(min)), LocalTime.of(hour, min));
					}
				}
				else {
					if (min < 10) {
						assertEquals(timeParser.parse(Integer.toString(hour) + "." + "0" + Integer.toString(min)), LocalTime.of(hour, min));
					}
					else {
						assertEquals(timeParser.parse(Integer.toString(hour) + "." + Integer.toString(min)), LocalTime.of(hour, min));
					}
				}
			}
		}
	}
}
```
###### src\tests\StorageControlTest.java
``` java

package tests;

import static org.junit.Assert.*;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import org.junit.Test;

import com.google.gson.Gson;

import storage.StorageControl;

public class StorageControlTest {
	
	/* WARNING: Do not use these test cases if you're actually using Pink Panther. If you really want to,
	 * 			back up the task list text files somewhere else before running these tests.
	 */
	
	@Test
	public void setStorageEnvironmentTest_NonBoundary_NoLatestDirectory() {
		StorageControl testStorageControl = new StorageControl();
		
		assertEquals(testStorageControl.setEnvironment(), "C:\\PPCalendar");
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void setStorageEnvironmentTest_NonBoundary_HaveLatestDirectory() {
		StorageControl testStorageControl = new StorageControl();
		Gson gsonWrite = new Gson();
		File testLatestDirectory = new File("C:\\TestTest");
		testLatestDirectory.mkdir();
		String json;
		
		BufferedWriter bw;
		try {
			bw = new BufferedWriter(new FileWriter(testStorageControl.getLatestDirectoryTextFile()));
			json = gsonWrite.toJson(testLatestDirectory);
			bw.write(json);
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		assertEquals(testStorageControl.setEnvironment(), "C:\\TestTest");
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void setStorageEnvironmentTest_Boundary_LatestDirectoryNotDirectory() {
		StorageControl testStorageControl = new StorageControl();
		
		BufferedWriter bw;
		try {
			bw = new BufferedWriter(new FileWriter(testStorageControl.getLatestDirectoryTextFile()));
			bw.write("{\"path\":\"C:\\\\hetjhertj\"}");
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		assertEquals(testStorageControl.setEnvironment(), "C:\\PPCalendar");
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void changeDirectoryTest_NonBoundary_ValidDirectory() {
		StorageControl testStorageControl = new StorageControl();
		testStorageControl.setEnvironment();
		
		assertEquals(testStorageControl.changeDirectory("C:\\PinkPantherCalendar"), true);
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void changeDirectoryTest_Boundary_SameAsCurrentDirectory() {
		StorageControl testStorageControl = new StorageControl();
		testStorageControl.setEnvironment();
		
		assertEquals(testStorageControl.changeDirectory("C:\\PPCalendar"), false);
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void changeDirectoryTest_Boundary_DirectoryExists() {
		StorageControl testStorageControl = new StorageControl();
		testStorageControl.setEnvironment();
		
		File PPCalendarTest = new File("C:\\TestCalendar");
		PPCalendarTest.mkdir();
		
		assertEquals(testStorageControl.changeDirectory("C:\\TestCalendar"), true);
		testStorageControl.deleteAllFiles();
	}
	
	@Test
	public void changeDirectoryTest_Boundary_InvalidDirectory() {
		StorageControl testStorageControl = new StorageControl();
		testStorageControl.setEnvironment();
		
		assertEquals(testStorageControl.changeDirectory("testing"), false);
		testStorageControl.deleteAllFiles();
	}
	
}
```
